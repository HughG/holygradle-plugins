import java.text.SimpleDateFormat


project.ext.writeRepoInfo = { File repoDir, OutputStream os ->
    // As long as we're not really publishing (and maybe just publishing locally for integration tests),
    // allow repos (most likely, the local repo) to have no ".hg" folder.
    boolean allowUnknown = !project.ext.getIsReallyPublishing()
    ExecResult result
    result = exec {
        executable = "hg"
        args = ["paths", "default"]
        standardOutput = os
        workingDir = repoDir
        ignoreExitValue = allowUnknown
    }
    if (result.exitValue != 0) {
        os.println("unknown_remote")
    }
    (new PrintStream(os)).withStream { it.print(" ") }
    result = exec {
        executable = "hg"
        args = ["id", "-ibt"]
        standardOutput = os
        workingDir = repoDir
        ignoreExitValue = allowUnknown
    }
    if (result.exitValue != 0) {
        os.println("unknown_id")
    }
}


/**
 * This task puts the Hg master repo URL and working directory version/branch/tags into a property and text file, which
 * feed into the packaging tasks for all sub-projects, so all build outputs are stamped with info on where they came
 * from.
 *
 *   - JAR files put it in META-INF/MANIFEST/MF.
 *   - custom-gradle puts it in the init.d/holy-gradle-init.gradle.
 *   - credential-store puts it in the Windows file properties of the generated EXE.
 *
 * If you change the form or location of this info, please update not only this comment but also the wiki page at
 * https://bitbucket.org/nm2501/holy-gradle-plugins/wiki/Home.
 */
task setHgVersionInfo {
    project.ext.hgVersionInfoFile = new File(project.buildDir, 'hgVersionInfo.txt')

    doLast {
        new ByteArrayOutputStream().withStream { OutputStream os ->
            writeRepoInfo(rootProject.projectDir, os)

            // Store both command outputs in one string with no line breaks.
            String infoWithoutDate = os.toString().replaceAll("[\\r\\n]", "")
            project.ext.hgVersion = infoWithoutDate.split()[1]

            // Add the date/time.
            (new PrintStream(os)).withStream { it.print(" ") }
            SimpleDateFormat rfc3339dateFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssXXX")
            if (project.hgVersion.endsWith('+')) {
                // There are local changes, so just use the current date/time.
                (new PrintStream(os)).withStream {
                    it.print(rfc3339dateFormat.format(new Date()))
                }
            } else {
                // Pull from the Hg log.
                exec {
                    executable = "hg"
                    args = ["log", "-r", project.hgVersion, "-T", '"{date|rfc3339date}"']
                    standardOutput = os
                }
            }
            String infoWithDate = os.toString().replaceAll("[\\r\\n]", "")

            // Only include the date/time if we're actually publishing.  It will change any time you
            // edit a file in the working copy, even if it's not an input to what you're building,
            // so if we include it, various things always get rebuilt (e.g., credential-store.exe).
            if (project.getIsPublishing()) {
                project.ext.hgVersionInfo = infoWithDate
            } else {
                project.ext.hgVersionInfo = infoWithoutDate
            }

            Date dateFromInfo = rfc3339dateFormat.parse(infoWithDate.split().last())
            SimpleDateFormat releaseNotesDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss z")
            releaseNotesDateFormat.setTimeZone(TimeZone.getTimeZone("UTC"));
            String releaseNotesDate = releaseNotesDateFormat.format(dateFromInfo)
            project.ext.releaseNoteInfo = "${project.hgVersion} at ${releaseNotesDate}"

            // Write the version to a file, so that the file can be seen as changed (or not) by
            // other tasks, to force them to re-run.
            if (!(project.buildDir.exists() || project.buildDir.mkdirs())) {
                throw new RuntimeException("Failed to create output folder for ${project.hgVersionInfo}")
            }
            project.hgVersionInfoFile.text = project.hgVersionInfo
        }

        String hgLocalDocFullVersionInfo = project.releaseNoteInfo
        final File localWebsiteDir = new File(project.WEBSITE_DIR, "local")
        if (localWebsiteDir.exists()) {
            new ByteArrayOutputStream().withStream { OutputStream os ->
                final File localWebsiteRealDir = localWebsiteDir.toPath().toRealPath().toFile()
                writeRepoInfo(localWebsiteRealDir, os)
                // Store both command outputs in one string with no line breaks.
                String infoWithoutDate = os.toString().replaceAll("[\\r\\n]", "")
                String rev = infoWithoutDate.split()[1]
                project.ext.hgLocalDocVersion = rev
            }
            hgLocalDocFullVersionInfo += " " + project.hgLocalDocVersion
        }

        project.ext.hgLocalDocFullVersionInfoURLEncoded = URLEncoder.encode(hgLocalDocFullVersionInfo, "UTF-8")
    }

    // Force setHgVersionInfo to always execute.  For tasks which depend on this, Gradle will
    // check the contents of the hgVersionInfoFile to see if they have really changed, and only
    // run those tasks if so.
    outputs.file(project.hgVersionInfoFile)
    outputs.upToDateWhen { false }
}

subprojects {
    // Add source version information for each plugin JAR.
    if (project.plugins.hasPlugin("groovy")) {
        // We don't need an "afterEvaluate" here because "jar" is a standard task for "groovy" projects.
        project.jar {
            inputs.files rootProject.setHgVersionInfo.outputs.files
            doFirst {
                manifest {
                    attributes(["Implementation-Version": rootProject.hgVersionInfo])
                }
            }
        }
    }
}
