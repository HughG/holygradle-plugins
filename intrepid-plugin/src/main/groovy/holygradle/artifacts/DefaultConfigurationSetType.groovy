package holygradle.artifacts

import holygradle.lang.NamedParameters
import org.gradle.api.artifacts.Configuration
import org.gradle.util.ConfigureUtil

import java.util.concurrent.atomic.AtomicInteger

/**
 * This configuration set type class forms its pattern of related configurations from several axes.  Each axis has a
 * name and a fixed set of values, and the set of configuration names comes from taking each possible combination of
 * values from those axes, in the order in which the axes were defined, and combining them into a string, separating the
 * values with an underscore.  A specific combination of values for each axis is referred to as a <em>binding</em>.
 *
 * The axes are divided into required and optional lists, and further names are generated by combining values from the
 * required axes with a single "{@code _common}" suffix.  The point of this is to support languages like C++ where some
 * dependencies and artifacts are platform-specific (using the optional axes) and some are platform-independent (when
 * the optional axes are replaced with "{@code _common}").  For example, in a typical use with Visual C++ there would be
 * a single required axis "stage", with values "{@code import}", "{@code runtime}", and "{@code debugging}", plus
 * optional axes "Platform" and "Configuration".  The link libraries for a C++ library would be related to
 * configurations such as {@code import_x64_Release} and {@code import_Win32_Release}, and the header files would be
 * related to {@code import_common}.  The configurations with the more specific axis values are intended to extend from
 * the corresponding common configurations -- because, for example, using C++ link libraries generally also require the
 * headers.
 *
 * This class also allows for a number of configurations which do not fit the above pattern and are marked as not
 * visible.  These are to support details of configuration mapping.  The subclasses of this class keep the same logic
 * for constructing names and add specific configuration mapping rules for the {@code import} axis.
 *
 * @see http://holygradle.bitbucket.org/plugin-intrepid.html#_configurationSetTypes
 * @see http://holygradle.bitbucket.org/plugin-intrepid.html#_pre_defined_configuration_set_types
 */
class DefaultConfigurationSetType implements ConfigurationSetType {
    public static final String STAGE_AXIS_NAME = "stage"
    public static final String IMPORT_STAGE = "import"
    public static final String RUNTIME_STAGE = "runtime"
    public static final String DEBUGGING_STAGE = "debugging"
    public static final String PRIVATE_BUILD_CONFIGURATION_NAME = "build"

    private final String name
    private final AtomicInteger nextSetId = new AtomicInteger()
    private LinkedHashMap<String, List<String>> requiredAxes
    private LinkedHashMap<String, List<String>> optionalAxes
    private LinkedHashSet<String> nonVisibleConfigurations

    private List<Map<String, String>> commonConfigurationsSpec = new ArrayList<LinkedHashMap<String, String>>()

    public DefaultConfigurationSetType(
        String name
    ) {
        this(name, [:], [:], new LinkedHashSet<String>())
    }

    public DefaultConfigurationSetType(
        String name,
        LinkedHashMap<String, List<String>> requiredAxes,
        LinkedHashMap<String, List<String>> optionalAxes
    ) {
        this(name, requiredAxes, optionalAxes, new LinkedHashSet<String>())
    }

    public DefaultConfigurationSetType(
        String name,
        LinkedHashMap<String, List<String>> requiredAxes,
        LinkedHashMap<String, List<String>> optionalAxes,
        LinkedHashSet<String> nonVisibleConfigurations
    ) {
        this.name = name
        this.requiredAxes = fixStrings(requiredAxes)
        this.optionalAxes = fixStrings(optionalAxes)
        this.nonVisibleConfigurations = nonVisibleConfigurations
        this.nonVisibleConfigurations << PRIVATE_BUILD_CONFIGURATION_NAME
    }

    @Override
    final String getName() {
        return name
    }

    public final LinkedHashMap<String, List<String>> getRequiredAxes() {
        return requiredAxes
    }

    // This is an API for use by build scripts, so ignore the "unused" warning.
    @SuppressWarnings("GroovyUnusedDeclaration")
    public final void setRequiredAxes(LinkedHashMap<String, List<String>> requiredAxes) {
        this.requiredAxes = fixStrings(requiredAxes)
    }

    // This is an API for use by build scripts, so ignore the "unused" warning.
    @SuppressWarnings("GroovyUnusedDeclaration")
    public final void requiredAxes(LinkedHashMap<String, List<String>> requiredAxes) {
        this.requiredAxes.putAll(fixStrings(requiredAxes))
    }

    public final LinkedHashMap<String, List<String>> getOptionalAxes() {
        return optionalAxes
    }

    // This is an API for use by build scripts, so ignore the "unused" warning.
    @SuppressWarnings("GroovyUnusedDeclaration")
    public final void setOptionalAxes(LinkedHashMap<String, List<String>> optionalAxes) {
        this.optionalAxes = fixStrings(optionalAxes)
    }

    // This is an API for use by build scripts, so ignore the "unused" warning.
    @SuppressWarnings("GroovyUnusedDeclaration")
    public final void optionalAxes(LinkedHashMap<String, List<String>> optionalAxes) {
        this.optionalAxes.putAll(fixStrings(optionalAxes))
    }

    // This is an API for use by build scripts, so ignore the "unused" warning.
    @SuppressWarnings("GroovyUnusedDeclaration")
    public final LinkedHashMap<String, List<String>> getAxes() {
        // Can't just use "+" here because it doesn't return LinkedHashMap.
        def result = new LinkedHashMap<String, List<String>>(requiredAxes)
        result.putAll(optionalAxes)
        return result
    }

    public final LinkedHashSet<String> getNonVisibleConfigurations() {
        return nonVisibleConfigurations
    }

    // This is an API for use by build scripts, so ignore the "unused" warning.
    @SuppressWarnings("GroovyUnusedDeclaration")
    public final void setNonVisibleConfigurations(LinkedHashSet<String> nonVisibleConfigurations) {
        this.nonVisibleConfigurations = nonVisibleConfigurations
    }

    // This is an API for use by build scripts, so ignore the "unused" warning.
    @SuppressWarnings("GroovyUnusedDeclaration")
    public final void nonVisibleConfigurations(Set<String> nonVisibleConfigurations) {
        this.nonVisibleConfigurations.addAll(nonVisibleConfigurations)
    }

    /**
     * Adds one or more mappings to the list returned by {@link #getCommonConfigurationsSpec()}.
     * @param commonConfigurationsSpec The mappings to add.
     */
    public void commonConfigurationsSpec(Map<String, String> ... commonConfigurationsSpec) {
        this.commonConfigurationsSpec(commonConfigurationsSpec.toList())
    }

    public void commonConfigurationsSpec(List<Map<String, String>> commonConfigurationsSpec) {
        if (requiredAxes.isEmpty()) {
            throw new RuntimeException("Must set requiredAxes before setting commonConfigurationsSpec")
        }
        // If any of the specs have axes which are not in the required list, that's an error.
        List<Map<String,String>> incorrectSpecs = commonConfigurationsSpec.findAll { spec ->
            !(spec.keySet() - requiredAxes.keySet()).isEmpty()
        }
        if (!incorrectSpecs.isEmpty()) {
            throw new RuntimeException(
                "commonConfigurationsSpec axis keys must all be in the requiredAxes map, but some were not: " +
                incorrectSpecs
            )
        }
        this.commonConfigurationsSpec.addAll(commonConfigurationsSpec)
    }

    /**
     * Returns a list of axis-value partial bindings for which a "{@code _common}" configuration should be created.  In
     * this case "partial" means that the binding may not have values for all axes.  Indeed, it should only have
     * bindings for some or all of the required axes.  For example, if the list contains only {@code
     * [["stage": "import"]]} then only {@code import_common} should be created, but if it contains
     * {@code [["stage": "import", ["stage": "runtime"]]]} then both {@code import_common} and {@code runtime_common}
     * are required.
     *
     * Within the {@link DefaultConfigurationSet} class, each binding provided by this type is matched against the
     * partial bindings returned from this method.  A "{@code _common}" configuration is created if any of the partial
     * bindings match.  A partial binding matches if all its axis values appear in the candidate binding.
     *
     * @return A list of axis-value mappings for which a "_common" configuration should be created.
     */
    public List<Map<String, String>> getCommonConfigurationsSpec() {
        return commonConfigurationsSpec
    }

    /**
     * Crates and returns a new instance of {@link DefaultConfigurationSet} and sets its type to this type.
     * @return A new instance of {@link DefaultConfigurationSet} whose type is set to this type.
     */
    // This is an API for use by build scripts, so ignore the "unused" warning.
    @SuppressWarnings("GroovyUnusedDeclaration")
    public DefaultConfigurationSet makeSet() {
        DefaultConfigurationSet result = new DefaultConfigurationSet("from ${name}, #${nextSetId.getAndIncrement()}")
        result.type(this)
        return result
    }

    /**
     * Crates and returns a new instance of {@link DefaultConfigurationSet} and sets its type to this type, then
     * configures it with the given closure.
     *
     * @return A new instance of {@link DefaultConfigurationSet} whose type is set to this type and which is configured
     * with the given closure.
     */
    // This is an API for use by build scripts, so ignore the "unused" warning.
    @SuppressWarnings("GroovyUnusedDeclaration")
    public DefaultConfigurationSet makeSet(Closure configure) {
        return ConfigureUtil.configure(configure, makeSet())
    }

    /**
     * Returns a string describing the given binding.
     * @param binding A map from axis names to axis values.
     * @return A string describing the {@code binding}.
     */
    public String getDescriptionForBinding(Map<String, String> binding) {
        String stage = binding[STAGE_AXIS_NAME]
        Map bindingWithoutStage = binding.findAll { k, v -> k != STAGE_AXIS_NAME }
        String restOfBindingDescription = (bindingWithoutStage.isEmpty()
            ? ", common to all values of ${optionalAxes.keySet()}"
            : ", with ${bindingWithoutStage.toMapString()}"
        )
        return "Files for the ${stage} stage of development${restOfBindingDescription}."
    }

    /**
     * Returns a description for one of the non-visible configurations supported by this type.
     * @param name The name of a non-visible configuration supported by this type.
     * @return A description for the configuration with the given {@code name}.
     */
    public String getDescriptionForNonVisibleConfiguration(String name) {
        switch (name) {
            case PRIVATE_BUILD_CONFIGURATION_NAME:
                "Private configuration for files needed to build this module, but not needed for other modules to use it.";
                break
            default:
                null
                break;
        }
    }

    @Override
    public final Collection<String> getMappingsTo(
        Map attrs,
        ConfigurationSet source,
        ConfigurationSet target
    ) {
        final DefaultConfigurationSet defaultSource = source as DefaultConfigurationSet
        final DefaultConfigurationSet defaultTarget = target as DefaultConfigurationSet
        if (defaultSource == null || defaultTarget == null) {
            throwForUnknownTypes(source, target)
        }
        return getDefaultMappingsTo(attrs, [:], defaultSource, defaultTarget)
    }

    @Override
    public final Collection<String> getMappingsTo(
        ConfigurationSet source,
        ConfigurationSet target
    ) {
        return getMappingsTo([:], source, target)
    }

    @Override
    public final Collection<String> getMappingsTo(
        Map attrs,
        ConfigurationSet source,
        ConfigurationSetType targetType
    ) {
        final DefaultConfigurationSet defaultSource = source as DefaultConfigurationSet
        final DefaultConfigurationSetType defaultTargetType = targetType as DefaultConfigurationSetType
        if (defaultSource == null || defaultTargetType == null) {
            throwForUnknownTypes(source, targetType)
        }
        DefaultConfigurationSet defaultTarget = new DefaultConfigurationSet("from configuration set ${source.name}")
        defaultTarget.type = targetType
        return getDefaultMappingsTo(attrs, [:], defaultSource, defaultTarget)
    }

    @Override
    public final Collection<String> getMappingsTo(
        ConfigurationSet source,
        ConfigurationSetType targetType
    ) {
        return getMappingsTo([:], source, targetType)
    }

    @Override
    public final Collection<String> getMappingsFrom(Map attrs, Configuration source) {
        DefaultConfigurationSet target = new DefaultConfigurationSet("from configuration ${source}")
        target.type = this
        return getDefaultMappingsFrom(attrs, [:], source, target)
    }

    @Override
    public final Collection<String> getMappingsFrom(Configuration source) {
        return getMappingsFrom([:], source)
    }

    @Override
    public final Collection<String> getMappingsFrom(Map attrs, Configuration source, ConfigurationSet target) {
        final DefaultConfigurationSet defaultTarget = target as DefaultConfigurationSet
        if (defaultTarget == null) {
            throwForUnknownTarget(target)
        }
        return getDefaultMappingsFrom(attrs, [:], source, defaultTarget)
    }

    @Override
    public final Collection<String> getMappingsFrom(Configuration source, ConfigurationSet target) {
        return getMappingsFrom([:], source, target)
    }

    /**
     * This method returns a collection of configuration mapping strings of the form "a->b", mapping configurations
     * from the {@code source} to configurations in the {@code target}, according to rules which are subclass-specific.
     *
     * If you override this, you should also override {@link holygradle.artifacts
     * .DefaultConfigurationSetType#getDefaultMappingsFrom(Map, Configuration, DefaultConfigurationSet)}
     *
     * @param attrs Optional extra arguments for use by subclasses.
     * @param source The source configuration set.
     * @param target The target configuration set.
     * @return
     */
    protected Collection<String> getDefaultMappingsTo(
        Map attrs,
        Map parameterSpecs,
        DefaultConfigurationSet source,
        DefaultConfigurationSet target
    ) {
        def (boolean export) = NamedParameters.checkAndGet(attrs, [export: false] + parameterSpecs)

        return getDefaultMappingsTo(source, target, getMappingAdder(export))
    }

    /**
     * This method returns a collection of configuration mapping strings of the form "a->b", mapping the {@code source}
     * configuration to some configurations in the {@code target}, according to rules which are subclass-specific.  That
     * means, if the source configuration is "foo" then every returned string will start with "foo->".
     *
     * If you override this, you should also override {@link holygradle.artifacts
     * .DefaultConfigurationSetType#getDefaultMappingsTo(Map, Map, DefaultConfigurationSet, DefaultConfigurationSet)}

     * @param attrs Optional extra arguments for use by subclasses.
     * @param source The source configuration name (not configuration set).
     * @param target The target configuration set.
     * @return
     */
    protected Collection<String> getDefaultMappingsFrom(
        Map attrs,
        Map parameterSpecs,
        Configuration source,
        DefaultConfigurationSet target
    ) {
        def (boolean export) = NamedParameters.checkAndGet(attrs, [export: false] + parameterSpecs)

        return getDefaultMappingsTo(source, target, getMappingAdder(export))
    }

    protected static final Collection<String> getDefaultMappingsTo(
        DefaultConfigurationSet source,
        DefaultConfigurationSet target,
        Closure maybeAddMapping
    ) {
        Map<Map<String, String>, String> sourceConfigurations = source.configurationNamesMap
        Map<Map<String, String>, String> targetConfigurations = target.configurationNamesMap

        DefaultConfigurationSetType sourceType = source.typeAsDefault
        def sourceOptionalAxesNames = sourceType.optionalAxes.keySet()
        List<String> mappings = new ArrayList<String>(sourceConfigurations.size())
        sourceConfigurations.each { Map<String, String> binding, String sourceConfigurationName ->
            if (!binding.keySet().any { sourceOptionalAxesNames.contains(it) }) {
                // Don't map this; only map configurations which have all parts specified.
                return
            }

            String targetConfigurationName = targetConfigurations.get(binding)
            if (targetConfigurationName == null) {
                throw new RuntimeException(
                    "Failed to find target for ${binding} (configuration name ${sourceConfigurationName}) " +
                    "in ${targetConfigurations}"
                )
            }

            maybeAddMapping(mappings, binding, sourceConfigurationName, targetConfigurationName)
        }

        return mappings
    }

    protected static final Collection<String> getDefaultMappingsTo(
        Configuration source,
        DefaultConfigurationSet target,
        Closure maybeAddMapping
    ) {
        Map<Map<String, String>, String> targetConfigurations = target.configurationNamesMap

        def targetOptionalAxesNames = target.typeAsDefault.optionalAxes.keySet()
        List<String> mappings = new ArrayList<String>(targetConfigurations.size())
        targetConfigurations.each { Map<String, String> binding, String targetConfigurationName ->
            if (!binding.keySet().any { targetOptionalAxesNames.contains(it) }) {
                // Don't map this; only map configurations which have all parts specified.
                return
            }

            maybeAddMapping(mappings, binding, source.name, targetConfigurationName)
        }

        return mappings
    }

    protected static final String makeMapping(String from, String to) {
        "${from}->${to}"
    }

    protected static Closure getMappingAdder(
        boolean export
    ) {
        return {
            Collection<String> mappings,
            Map<String, String> binding,
            String sourceConfigurationName,
            String targetConfigurationName
             ->
            if (binding['stage'] == IMPORT_STAGE) {
                // Link import to a public config iff export == true
                String sourceName = export ? sourceConfigurationName : PRIVATE_BUILD_CONFIGURATION_NAME
                mappings << makeMapping(sourceName, targetConfigurationName)
            } else {
                mappings << makeMapping(sourceConfigurationName, targetConfigurationName)
            }
        }
    }

    protected final void throwForUnknownTarget(ConfigurationSet target) {
        throw new RuntimeException(
            "${this.class} only supports configuration sets of class ${DefaultConfigurationSet.class} " +
                "and configuration types of class ${WindowsConfigurationSetType.class} " +
                "but received a target of ${target?.class}"
        )
    }

    protected final void throwForUnknownTargetType(ConfigurationSetType targetType) {
        throw new RuntimeException(
            "${this.class} only supports configuration sets of class ${DefaultConfigurationSet.class} " +
                "and configuration types of class ${WindowsConfigurationSetType.class} " +
                "but received a target type of ${targetType?.class}"
        )
    }

    protected void throwForUnknownTypes(ConfigurationSet source, ConfigurationSet target) {
        throw new RuntimeException(
            "${this.class} only supports configuration sets of class ${DefaultConfigurationSet.class} " +
            "and configuration types of class ${WindowsConfigurationSetType.class} " +
            "but received a source of ${source?.class}, and a target of ${target?.class}"
        )
    }

    protected void throwForUnknownTypes(ConfigurationSet source, ConfigurationSetType targetType) {
        throw new RuntimeException(
            "${this.class} only supports configuration sets of class ${DefaultConfigurationSet.class} " +
                "and configuration types of class ${WindowsConfigurationSetType.class} " +
                "but received a source of ${source?.class}, and a target type of ${targetType?.class}"
        )
    }

    @Override
    public String toString() {
        return "DefaultConfigurationSetType{" +
            "name='" + name + '\'' +
            ", requiredAxes=" + requiredAxes +
            ", optionalAxes=" + optionalAxes +
            ", nonVisibleConfigurations=" + nonVisibleConfigurations +
            '}';
    }

    // Fix up for Groovy not always auto-converting from GString to String.
    private final LinkedHashMap<String, List<String>> fixStrings(LinkedHashMap<String, List<String>> map) {
        LinkedHashMap<String, List<String>> fixedMap = new LinkedHashMap<>()
        map.each { k, v -> fixedMap[k.toString()] = v*.toString() }
        fixedMap
    }
}
