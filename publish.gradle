import org.gradle.process.ExecSpec

def propertyOrNull(Object o, String propertyName) {
    o.hasProperty(propertyName) ? o.property(propertyName) : null
}

// Pick a version number.
String publishVersion = "unspecified"
String publishVersionFromProperty = propertyOrNull(project, "publishVersion")
if (publishVersionFromProperty != null) {
    publishVersion = publishVersionFromProperty
} else {
    String username = System.getProperty("user.name").toLowerCase()
    publishVersion = "${username}-SNAPSHOT"
}
project.allprojects { Project p ->
    p.version = publishVersion
    p.logger.info "Set ${p.name} version to ${p.version}"
}

void setPublishTaskDescription(
    Task t,
    String publishingGroup,
    String snapshotTargetUri,
    String releaseTargetUri
) {
    t.group = "Publishing"
    String targetDescription
    if (snapshotTargetUri == releaseTargetUri) {
        targetDescription = releaseTargetUri
    } else {
        targetDescription = "${snapshotTargetUri} for snapshots, or ${releaseTargetUri} for releases"
    }
    t.description = "Publish snapshot or (using 'publishVersion' property) release of ${publishingGroup} to ${targetDescription}"
}

// Set up publish tasks for root project.
project.task("beforePublish") {
    description = "Task dependency for any work needed before publishing any project"
    dependsOn setHgVersionInfo
}
project.ext.publishTasks = []
project.ext.publishReallyTasks = []
project.ext.getIsPublishing = {
    project.publishTasks.any { project.gradle.taskGraph.hasTask(it) }
}
["Plugins", "CustomGradle"].each { String publishingGroup ->
    Task publishReally = project.task("publish${publishingGroup}Really") { Task t ->
        setPublishTaskDescription(t, publishingGroup, PUBLISH_SNAPSHOT_TARGET_URI, PUBLISH_RELEASE_TARGET_URI)

        final boolean isSnapshot = project.version.toString().endsWith('-SNAPSHOT')
        final localPublishingGroup = publishingGroup // capture for closure
        if (!isSnapshot) {
            doLast {
                // Tag the repo
                String tagPrefixEnding
                switch (localPublishingGroup) {
                    case "Plugins":
                        tagPrefixEnding = 'P';
                        break;
                    case "CustomGradle":
                        tagPrefixEnding = 'C';
                        break;
                    default:
                        throw new RuntimeException("Internal error: unknown publishingGroup ${localPublishingGroup}")
                }
                final String tag = "TR${tagPrefixEnding}_${project.version.tr('.', '-')}"
                project.exec {
                    workingDir projectDir
                    commandLine 'hg.exe', 'tag', '-f', '-m', "${t.name} for ${tag}", tag
                }
                println "Tagged public repo; now push the tag."
            }
        }
    }
    project.publishTasks << publishReally
    project.publishReallyTasks << publishReally

    project.publishTasks << project.task("publish${publishingGroup}Locally") { Task t ->
        setPublishTaskDescription(t, publishingGroup, PUBLISH_LOCAL_TARGET_URI, PUBLISH_LOCAL_TARGET_URI)
    }
}
project.publishTasks.each { Task t ->
    t.dependsOn beforePublish
}

// Make sure that the credential-store EXE and the custom-gradle distributions get rebuilt if the
// version number changes.  (We don't need to do anything explicit for Groovy plugin projects
// because their output is a JAR, which has the version number in its filename.)
task setPublishVersion {
    project.ext.publishVersionFile = new File(project.buildDir, 'publishVersion.txt')

    doLast {
        // Write the version to a file, so that the file can be seen as changed (or not) by other
        // tasks, to force them to re-run.
        project.publishVersionFile.text = publishVersion
    }
    // Force setPublishVersion to always execute.  For tasks which depend on this, Gradle will
    // check the contents of the publishVersionFile to see if they have really changed, and only
    // run those tasks if so.
    outputs.file(project.publishVersionFile)
    outputs.upToDateWhen { false }
}

project.ext.getHasUncommittedChanges = {
    final String hgNode = project.hgVersionInfo.split(' ')[1]
    return hgNode.endsWith('+')
}

project.ext.getHasNonPublicParent = { File dir ->
    final OutputStream stdout = new ByteArrayOutputStream()
    project.exec { ExecSpec spec ->
        spec.workingDir dir
        spec.executable = "hg"
        spec.args = ["phase", "."]
        spec.setStandardOutput stdout
    }
    final String output = stdout.toString().trim()
    final String phase = output.split()[1]
    return (phase != "public")
}

// Print a message, if we're actually publishing.
project.gradle.taskGraph.whenReady {
    if (project.getIsPublishing()) {
        project.tasks['setHgVersionInfo'].doLast {
            // Fail early if any release publishing preconditions are not met.
            if (!project.version.toString().endsWith('-SNAPSHOT')) {
                if (project.getHasUncommittedChanges()) {
                    throw new RuntimeException("Cannot publish a non-SNAPSHOT version with uncommitted changes.")
                }

                if (project.getHasNonPublicParent(project.projectDir)) {
                    throw new RuntimeException("Cannot publish a non-SNAPSHOT version from non-public parent revision.")
                }
            }
        }

        println()
        println "Publishing as version '${publishVersion}'..."
        println()
    }
}

project.subprojects {
    // The integration project just has tests, and doesn't publish anything.
    if (project.name == "integration") {
        return
    }

    // Add local repo to repos used for dependencies.
    repositories {
        ivy {
            url PUBLISH_LOCAL_TARGET_URI
        }
    }
    
    String publishingGroup =
        (project.name.endsWith("-plugin") || project.name == "credential-store") ?
            "Plugins" :
            "CustomGradle";

    // Set up publish tasks for each subproject.
    project.ext.publishTasks = []
    project.publishTasks << project.task("publish${publishingGroup}Really", type: Upload) { Upload t ->
        setPublishTaskDescription(t, publishingGroup, PUBLISH_SNAPSHOT_TARGET_URI, PUBLISH_RELEASE_TARGET_URI)
        t.configuration = configurations.default
        t.uploadDescriptor = true
        t.descriptorDestination = new File(project.buildDir, "ivy.xml")
        t.dependsOn(t.configuration.getTaskDependencyFromProjectDependency(true, t.name))
        // Add a dependency on the root project's beforePublish task, so that it will be triggered
        // to set up the version number and because it brings in a dependency on integration testing.
        t.dependsOn rootProject.tasks["beforePublish"]
        rootProject.tasks[t.name].dependsOn t

        final boolean isSnapshot = project.version.toString().endsWith('-SNAPSHOT')
        t.ext.targetUri = isSnapshot ? PUBLISH_SNAPSHOT_TARGET_URI: PUBLISH_RELEASE_TARGET_URI
        t.repositories.ivy {
            credentials {
                username artifactoryUsername
                password artifactoryPassword
            }
            url t.targetUri
        }
    }
    project.publishTasks << project.task("publish${publishingGroup}Locally", type: Upload) { Upload t ->
        t.configuration = configurations.default
        setPublishTaskDescription(t, publishingGroup, PUBLISH_LOCAL_TARGET_URI, PUBLISH_LOCAL_TARGET_URI)
        t.uploadDescriptor = true
        t.descriptorDestination = new File(project.buildDir as File, "ivy.xml")
        t.dependsOn(t.configuration.getTaskDependencyFromProjectDependency(true, t.name))
        // Add a dependency on the root project, so that it will be triggered to set up the version number, by the
        // existence of that task in the task graph.
        t.dependsOn rootProject.tasks[t.name]

        t.ext.targetUri = PUBLISH_LOCAL_TARGET_URI
        t.repositories.ivy {
            url t.targetUri
        }

        // The credential-store project build file has to set up its own, slightly different input dependencies.
        if (project.name != "credential-store") {
            t.inputs.file new File(
                project.projectDir as File,
                "/build/libs/${project.name}-${project.version}.jar"
            )
        }
        t.outputs.dir t.targetUri.toString() + "${project.group}/${project.name}/${project.version}"
    }
    project.publishTasks.each { Task t ->
        t.doLast {
            println "Published ${project.name} ${project.version} " +
                "to ${t.targetUri} at ${new Date()} from ${project.releaseNoteInfo}"
        }
    }
}

project.tasks["clean"].doLast {
    project.delete(PUBLISH_LOCAL_TARGET_URI)
}