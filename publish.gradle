import org.gradle.process.ExecSpec

def propertyOrNull(Object o, String propertyName) {
    o.hasProperty(propertyName) ? o.property(propertyName) : null
}

// Pick a version number.
String publishVersion = "unspecified"
String publishVersionFromProperty = propertyOrNull(project, "publishVersion")
if (publishVersionFromProperty != null) {
    publishVersion = publishVersionFromProperty
} else {
    String username = System.getProperty("user.name").toLowerCase()
    publishVersion = "0.0-${username}SNAPSHOT-0"
}
project.allprojects { Project p ->
    p.version = publishVersion
    p.logger.info "Set ${p.name} version to ${p.version}"
}

void setPublishTaskDescription(
    Task t,
    String snapshotTargetUri,
    String releaseTargetUri
) {
    t.group = "Publishing"
    String targetDescription
    if (snapshotTargetUri == releaseTargetUri) {
        targetDescription = releaseTargetUri
    } else {
        targetDescription = "${snapshotTargetUri} for snapshots, or ${releaseTargetUri} for releases"
    }
    t.description = "Publish snapshot or (using 'publishVersion' property) release to ${targetDescription}"
}

// Set up publish tasks for root project.
project.task("beforePublish") {
    description = "Task dependency for any work needed before publishing any project"
    dependsOn setHgVersionInfo
}
project.ext.publishTasks = []
project.ext.publishReallyTasks = []
project.ext.getIsPublishing = {
    project.publishTasks.any { project.gradle.taskGraph.hasTask(it) }
}
project.ext.getIsReallyPublishing = {
    project.publishReallyTasks.any { project.gradle.taskGraph.hasTask(it) }
}
Task publishReally = project.task("publishPluginsReally") { Task t ->
    setPublishTaskDescription(t, PUBLISH_SNAPSHOT_TARGET_URI, PUBLISH_RELEASE_TARGET_URI)

    final boolean isSnapshot = project.version.toString().endsWith('SNAPSHOT-0')
    if (!isSnapshot) {
        doLast {
            // Tag the repo
            final String tag = "TRP_${project.version.tr('.', '-')}"
            project.exec {
                workingDir projectDir
                commandLine 'hg.exe', 'tag', '-f', '-m', "${t.name} for ${tag}", tag
            }
            println "Tagged public repo; now push the tag."
        }
    }
}
project.publishTasks << publishReally
project.publishReallyTasks << publishReally

project.publishTasks << project.task("publishPluginsLocally") { Task t ->
    setPublishTaskDescription(t, PUBLISH_LOCAL_TARGET_URI, PUBLISH_LOCAL_TARGET_URI)
}
project.publishTasks.each { Task t ->
    t.dependsOn beforePublish
}

// Make sure that the credential-store EXE and the custom-gradle distributions get rebuilt if the
// version number changes.  (We don't need to do anything explicit for Groovy plugin projects
// because their output is a JAR, which has the version number in its filename.)
task setPublishVersion {
    project.ext.publishVersionFile = new File(project.buildDir, 'publishVersion.txt')

    doLast {
        // Write the version to a file, so that the file can be seen as changed (or not) by other
        // tasks, to force them to re-run.
        project.publishVersionFile.text = publishVersion
    }
    // Force setPublishVersion to always execute.  For tasks which depend on this, Gradle will
    // check the contents of the publishVersionFile to see if they have really changed, and only
    // run those tasks if so.
    outputs.file(project.publishVersionFile)
    outputs.upToDateWhen { false }
}

project.ext.getHasUncommittedChanges = {
    final String hgNode = project.hgVersionInfo.split(' ')[1]
    return hgNode.endsWith('+')
}

project.ext.getHasNonPublicParent = { File dir ->
    final OutputStream stdout = new ByteArrayOutputStream()
    project.exec { ExecSpec spec ->
        spec.workingDir dir
        spec.executable = "hg"
        spec.args = ["phase", "."]
        spec.setStandardOutput stdout
    }
    final String output = stdout.toString().trim()
    final String phase = output.split()[1]
    return (phase != "public")
}

// Print a message, if we're actually publishing.
project.gradle.taskGraph.whenReady {
    if (project.getIsPublishing()) {
        project.tasks['setHgVersionInfo'].doLast {
            // Fail early if any release publishing preconditions are not met.
            if (!project.version.toString().endsWith('SNAPSHOT-0')) {
                if (project.getHasUncommittedChanges()) {
                    throw new RuntimeException("Cannot publish a non-SNAPSHOT version with uncommitted changes.")
                }

                if (project.getHasNonPublicParent(project.projectDir)) {
                    throw new RuntimeException("Cannot publish a non-SNAPSHOT version from non-public parent revision.")
                }
            }
        }

        println()
        println "Publishing as version '${publishVersion}'..."
        println()
    }
}

project.subprojects {
    // The integration project just has tests, and doesn't publish anything.
    if (project.name == "integration") {
        return
    }

    // Add local repo to repos used for dependencies.
    repositories {
        ivy {
            url PUBLISH_LOCAL_TARGET_URI
        }
    }

    // Set up publish tasks for each subproject.
    project.ext.publishTasks = []
    project.publishTasks << project.task("publishPluginsReally", type: Upload) { Upload t ->
        setPublishTaskDescription(t, PUBLISH_SNAPSHOT_TARGET_URI, PUBLISH_RELEASE_TARGET_URI)
        t.configuration = configurations.default
        t.uploadDescriptor = true
        t.descriptorDestination = new File(project.buildDir, "ivy.xml")
        t.dependsOn(t.configuration.getTaskDependencyFromProjectDependency(true, t.name))
        // Add a dependency on the root project's beforePublish task, so that it will be triggered
        // to set up the version number and because it brings in a dependency on integration testing.
        t.dependsOn rootProject.tasks["beforePublish"]
        rootProject.tasks[t.name].dependsOn t

        final boolean isSnapshot = project.version.toString().endsWith('SNAPSHOT-0')
        t.ext.targetUri = isSnapshot ? PUBLISH_SNAPSHOT_TARGET_URI : PUBLISH_RELEASE_TARGET_URI
        if (project.hasProperty('artifactoryServer')) {
            t.repositories.ivy {
                credentials {
                    username artifactoryUsername
                    password artifactoryPassword
                }
                url t.targetUri
            }
        } else {
            t.doFirst {
                throw new RuntimeException('Cannot publish because Artifactory server properties are not set')
            }
        }
    }
    project.publishTasks << project.task("publishPluginsLocally", type: Upload) { Upload t ->
        t.configuration = configurations.default
        setPublishTaskDescription(t, PUBLISH_LOCAL_TARGET_URI, PUBLISH_LOCAL_TARGET_URI)
        t.uploadDescriptor = true
        t.descriptorDestination = new File(project.buildDir as File, "ivy.xml")
        t.dependsOn(t.configuration.getTaskDependencyFromProjectDependency(true, t.name))
        // Add a dependency on the root project, so that it will be triggered to set up the version number, by the
        // existence of that task in the task graph.
        t.dependsOn rootProject.tasks[t.name]

        t.ext.targetUri = PUBLISH_LOCAL_TARGET_URI
        t.repositories.ivy {
            url t.targetUri
        }

        // The credential-store project build file has to set up its own, slightly different input dependencies.
        if (project.name != "credential-store") {
            t.inputs.file new File(
                project.projectDir as File,
                "/build/libs/${project.name}-${project.version}.jar"
            )
        }
        t.outputs.dir t.targetUri.toString() + "${project.group}/${project.name}/${project.version}"
    }
    project.publishTasks.each { Task t ->
        t.doLast {
            println "Published ${project.name} ${project.version} " +
                "to ${t.targetUri} at ${new Date()} from ${project.releaseNoteInfo}"
        }
    }
}

project.tasks["clean"].doLast {
    project.delete(PUBLISH_LOCAL_TARGET_URI)
}