import org.gradle.process.ExecSpec

def propertyOrNull(Object o, String propertyName) {
    o.hasProperty(propertyName) ? o.property(propertyName) : null
}

void setPublishTaskDescription(Task t, String publishingGroup, String targetUri) {
    t.group = "Publishing"
    t.description = "Publish snapshot or (using 'publishVersion' property) release of ${publishingGroup} to ${targetUri}"
}

// Set up publish tasks for root project.
project.ext.publishTasks = []
project.ext.publishReallyTasks = []
["Plugins", "CustomGradle"].each { String publishingGroup ->
    Task publishReally = project.task("publish${publishingGroup}Really") { Task t ->
        setPublishTaskDescription(t, publishingGroup, PUBLISH_TARGET_URI)
    }
    project.publishTasks << publishReally
    project.publishReallyTasks << publishReally

    project.publishTasks << project.task("publish${publishingGroup}Locally") { Task t ->
        setPublishTaskDescription(t, publishingGroup, PUBLISH_LOCAL_TARGET_URI)
    }
}
project.publishTasks.each { Task t ->
    t.dependsOn setHgVersionInfo
}

// Pick a version number.
String publishVersion = "unspecified"
String publishVersionFromProperty = propertyOrNull(project, "publishVersion")
if (publishVersionFromProperty != null) {
    publishVersion = publishVersionFromProperty
} else {
    String username = System.getProperty("user.name").toLowerCase()
    publishVersion = "${username}-SNAPSHOT"
}
project.allprojects { Project p ->
    p.version = publishVersion
    p.logger.info "Set ${p.name} version to ${p.version}"
}

// Make sure that the credential-store EXE and the custom-gradle distributions get rebuilt if the
// version number changes.  (We don't need to do anything explicit for Groovy plugin projects
// because their output is a JAR, which has the version number in its filename.)
task setPublishVersion {
    project.ext.publishVersionFile = new File(project.buildDir, 'publishVersion.txt')

    doLast {
        // Write the version to a file, so that the file can be seen as changed (or not) by other
        // tasks, to force them to re-run.
        project.publishVersionFile.text = publishVersion
    }
    // Force setPublishVersion to always execute.  For tasks which depend on this, Gradle will
    // check the contents of the publishVersionFile to see if they have really changed, and only
    // run those tasks if so.
    outputs.file(project.publishVersionFile)
    outputs.upToDateWhen { false }
}

// Print a message, if we're actually publishing.
project.gradle.taskGraph.whenReady {
    if (project.publishTasks.any { project.gradle.taskGraph.hasTask(it) }) {

        project.tasks['setHgVersionInfo'].doLast {
            // Fail early if any release publishing preconditions are not met.
            if (!project.version.toString().endsWith('-SNAPSHOT')) {
                final String hgNode = project.hgVersionInfo.split(' ')[1]
                final boolean hasUncommittedChanges = hgNode.endsWith('+')
                if (hasUncommittedChanges) {
                    throw new RuntimeException("Cannot publish a non-SNAPSHOT version with uncommitted changes.")
                }

                final OutputStream stdout = new ByteArrayOutputStream()
                project.exec { ExecSpec spec ->
                    spec.executable = "hg"
                    spec.args = ["phase", "."]
                    spec.setStandardOutput stdout
                }
                final String output = stdout.toString().trim()
                final String phase = output.split()[1]
                if (phase != "public") {
                    throw new RuntimeException("Cannot publish a non-SNAPSHOT version from non-public parent revision.")
                }
            }
        }

        println()
        println "Publishing as version '${publishVersion}'..."
        println()
    }
}

project.subprojects {
    // The integration project just has tests, and doesn't publish anything.
    if (project.name == "integration") {
        return
    }

    // Add local repo to repos used for dependencies.
    repositories {
        ivy {
            url PUBLISH_LOCAL_TARGET_URI
        }
    }
    
    String publishingGroup =
        (project.name.endsWith("-plugin") || project.name == "credential-store") ?
            "Plugins" :
            "CustomGradle";

    // Set up publish tasks for each subproject.
    project.ext.publishTasks = []
    project.publishTasks << project.task("publish${publishingGroup}Really", type: Upload) { Upload t ->
        setPublishTaskDescription(t, publishingGroup, PUBLISH_TARGET_URI)
        t.configuration = configurations.default
        t.uploadDescriptor = true
        t.descriptorDestination = new File(project.buildDir, "ivy.xml")
        t.dependsOn(t.configuration.getTaskDependencyFromProjectDependency(true, t.name))
        // Add a dependency on the root project, so that it will be triggered to set up the version number, by the
        // existence of that task in the task graph, and because it brings in a dependency on integration testing.
        t.dependsOn rootProject.tasks[t.name]

        t.repositories.ivy {
            credentials {
                username artifactoryUsername
                password artifactoryPassword
            }
            url PUBLISH_TARGET_URI
        }
    }
    project.publishTasks << project.task("publish${publishingGroup}Locally", type: Upload) { Upload t ->
        t.configuration = configurations.default
        setPublishTaskDescription(t, publishingGroup, PUBLISH_LOCAL_TARGET_URI)
        t.uploadDescriptor = true
        t.descriptorDestination = new File(project.buildDir as File, "ivy.xml")
        t.dependsOn(t.configuration.getTaskDependencyFromProjectDependency(true, t.name))
        // Add a dependency on the root project, so that it will be triggered to set up the version number, by the
        // existence of that task in the task graph.
        t.dependsOn rootProject.tasks[t.name]

        t.repositories.ivy {
            url PUBLISH_LOCAL_TARGET_URI
        }

        // The credential-store project build file has to set up its own, slightly different input dependencies.
        if (project.name != "credential-store") {
            t.inputs.file new File(
                project.projectDir as File,
                "/build/libs/${project.name}-${project.version}.jar"
            )
        }
        t.outputs.dir PUBLISH_LOCAL_TARGET_URI.toString() + "${project.group}/${project.name}/${project.version}"
    }
    project.publishTasks.each { Task t ->
        t.doLast {
            println "Published ${project.name} ${project.version} " +
                "to ${PUBLISH_TARGET_URI} at ${new Date()} from ${project.releaseNoteInfo}"
        }
    }
}

project.tasks["clean"].doLast {
    project.delete(PUBLISH_LOCAL_TARGET_URI)
}