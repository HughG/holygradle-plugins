include::stdattr.ascinc[]

= intrepid-plugin

include::sitemap.ascinc[]


== Overview

=== What is it?

This is a custom plugin for Gradle for retrieving source-code dependencies and other dependencies consisting of multiple zip files. It also supports publishing artifacts as collections of zip files. 

* Default dependency settings
** Fail on version conflict by default (configurable)
* Configurations
** Create sets of related configurations following standard patterns.
* Source code dependencies
** Retrieving source code repositories from SVN and Mercurial
** Caching credentials for SVN and Mercurial
** Gradle configuration-based dependency mapping
* Packed dependencies
** Retrieving dependencies consisting of many files into your workspace
** Central cache for unpacked dependencies & symlink from workspace to central cache
** Configurable symlinks from consumer module to multiple locations in unpacked dependency
** Support for using multiple versions of the same component
* Publishing
** Support for creating multiple packages (i.e. zip files)
** Uploading to Gradle format repository with Ivy metadata in +ivy.xml+ file

=== Example build script

Here is an example build script:

[source,groovy]
----
buildscript {
    gplugins.use "intrepid-plugin:7.7.2"
}
gplugins.apply()

group = "com.my-company.my-team"
version = System.getenv("NEXT_VERSION_NUMBER") ?: Project.DEFAULT_VERSION

repositories.ivy {
    url "http://artifactory-server/artifactory/libs-release"
    credentials {
        username my.username("Artifactory")
        password my.password("Artifactory")
    }
}

// dependenciesSettings.defaultFailOnVersionConflict = false

configurationsSets {
    main { type configurationSetTypes.DLL_64 }
    test {
        type configurationSetTypes.EXE_64
        prefix "test"
    }
}

sourceDependencies {
    framework {
        // Assume the following repo contains a build.gradle setting
        // group "com.my-company.my-team" and version "1.0.3.987".
        svn "http://svn-server/path/to/framework"
        configurationSet configurationSets.main, configurationSetTypes.DLL_64
    }
    "another-lib" {
        hg "http://hg-server/scm/path/to/another-lib"
    }
}

packedDependencies {
    RenderingLib {
        dependency "com.my-company.rendering:RenderingLib:2012a2"
        configurationSet configurationSets.main, configurationSetTypes.LIB_64
    }
    "NUnit <version> {
        dependency "org.nunit:NUnit:2.5.10"
        // This is an example of setting up configuraton mappings to a module which
        // does not use the same configuration naming scheme, so we can't map to a
        // configurationSetType.
        def testRuntimeConfs = configurationSets.test.configurationNamesMap.findAll { k, v ->
            k[stage] == 'runtime'
        }
        configuration "${testRuntimeConfs.join(',')}->bin"
        unpackToCache = false
    }
}

packageArtifacts {
    import_common {
        include "src/**/*.h"
    }
    configurationSets.main.axes['Configuration'].each { conf ->
        "import_x64_{conf}" {
            include "lib/${conf}/*.lib"
        }
        "runtime_x64_{conf}" {
            include "bin/${conf}/*.dll"
        }
        "debugging_x64_{conf}" {
            include "bin/${conf}/*.pdb"
        }
    }
}

publishPackages {
    repositories.ivy {
        credentials {
            username my.username("Artifactory")
            password my.password("Artifactory")
        }
        url "http://artifactory-server/artifactory/my-integration-repo/"
    }
}
----


This script does the following:

* Makes use of a specific version of the intrepid plugin.
* Describes which repository to use for satisfying dependencies, including credentials.
* Defines
link:http://www.gradle.org/docs/1.4/userguide/userguide_single.html#configurations[configurations]
for this module using the <<_configurationSets>> gloss:dsl[], suitable for this module packaging a
DLL, and having unit test executables which may have different dependencies.
* Defines 'framework' as a source code dependency:
** When dependencies are fetched, an SVN checkout operation will fetch the 'framework' source code
to '<workspace>/framework'. 
** When 'this' module is published, the source-code dependency will be converted to a published
module dependency, using the group, name, and version defined by the +build.gradle+ in that source
dependency.
* Defines 'another-lib' as a source code dependency:
** When dependencies are fetched, an Hg clone operation will fetch the source code to
'<workspace>/another-lib'.
** When 'this' module is published, the source-code dependency will not be mentioned.
* Defines 'RenderingLib' as a dependency:
** When dependencies are fetched, all packages belonging to the specified configurations will be
fetched from the repository. 
** When 'this' module is published, the gloss:ivy-xml[] will contain a module dependency for that
module, with appropriate configuration mappings from the configurations in the "main" configuration set.
** The packages will be unpacked to a central cache. (The cache settings can be configured.)
** A symlink will be created from the workspace to the unpacked copy of 'RenderingLib'.
* Defines 'NUnit' as a dependency:
** When dependencies are fetched, all packages belonging to the 'bin' configuration will be fetched
from the repository and unpacked directly into '<workspace>/NUnit 2.5.10'.
** When 'this' module is published, the gloss:ivy-xml[] will contain a module dependency for that
module, with appropriate configuration mappings from the configurations in the "test" configuration set.
* Packages are defined for 'this' module:
** These will be created when the +publish+ task is invoked.
** Each package belongs to exactly one configuration (although configurations can extend one another).
** It is possible to name a package differently from the configuration (not shown here).
** Some Groovy logic helps to define the packages 'import_x64_Debug', 'import_x64_Release', and so on.
* Publishing settings are configured, including:
** which repository to publish to;
** the credentials for the repository;
** the group (set at the top of the file), name (implicit from the containing folder name, or set in
+settings.gradle+), and version (also at the top of the file, using an environment variable).

For the above script the intrepid plugin makes the following tasks available (plus others described later):

....
Dependencies tasks
------------------
fetchAllDependencies - Retrieves all 'packedDependencies' and 'sourceDependencies', and sets up necessary symlinks.
rebuildSymlinks - Rebuild all symlinks.

Publishing tasks
----------------
packageEverything - Creates all zip packages for project 'example1'.
publish - Publishes all publications to all repositories.
publishIvyPublicationToIvyRepository - Publishes Ivy publication 'ivy' to Ivy repository 'ivy'.
....


When published, the Ivy module description for this example module will look like this:

[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<ivy-module version="2.0">
  <info organisation="com.my-company.my-team" module="example" revision="1.2.3.4" status="release" publication="20121115134228"/>
  <configurations>
    <conf name="build" visibility="private"/>
    <conf name="import_common" visibility="public"/>
    <conf name="import_x64_Release" visibility="public" extends="import_common"/>
    <conf name="import_x64_Debug" visibility="public" extends="import_common"/>
    <conf name="runtime_x64_Release" visibility="public"/>
    <conf name="runtime_x64_Debug" visibility="public"/>
    <conf name="debugging_x64_Release" visibility="public"/>
    <conf name="debugging_x64_Debug" visibility="public"/>
    <conf name="test_import_common" visibility="public"/>
    <conf name="test_import_x64_Release" visibility="public" extends="test_import_common"/>
    <conf name="test_import_x64_Debug" visibility="public" extends="test_import_common"/>
    <conf name="test_runtime_x64_Release" visibility="public"/>
    <conf name="test_runtime_x64_Debug" visibility="public"/>
    <conf name="test_debugging_x64_Release" visibility="public"/>
    <conf name="test_debugging_x64_Debug" visibility="public"/>
  </configurations>
  <publications>
    <artifact name="example-import_common" type="zip" ext="zip" conf="import_common"/>
    <artifact name="import_x64_Release" type="zip" ext="zip" conf="import_x64_Release"/>
    <artifact name="import_x64_Debug" type="zip" ext="zip" conf="import_x64_Debug"/>
    <artifact name="runtime_x64_Release" type="zip" ext="zip" conf="runtime_x64_Release"/>
    <artifact name="runtime_x64_Debug" type="zip" ext="zip" conf="runtime_x64_Debug"/>
    <artifact name="debugging_x64_Release" type="zip" ext="zip" conf="debugging_x64_Release"/>
    <artifact name="debugging_x64_Debug" type="zip" ext="zip" conf="debugging_x64"/>
  </publications>
  <dependencies>
    <dependency org="com.my-company.my-team" name="framework" rev="1.0.3.987" conf="import_x64_Release->import_x64_Release;import_x64_Debug->import_x64_Debug;runtime_x64_Release->runtime_x64_Release;runtime_x64_Debug->runtime_x64_Debug;debugging_x64_Release->debugging_x64_Release;debugging_x64_Debug->debugging_x64_Debug"/>
    <dependency org="com.my-company.rendering" name="RenderingLib" rev="2012a2" conf="import_x64_Release->import_x64_Release;import_x64_Debug->import_x64_Debug;runtime_x64_Release->runtime_x64_Release;runtime_x64_Debug->runtime_x64_Debug;debugging_x64_Release->debugging_x64_Release;debugging_x64_Debug->debugging_x64_Debug"/>
    <dependency org="org.nunit" name="NUnit" rev="2.5.10" conf="test_runtime_x64_Release,test_runtime_x64_Debug->bin"/>
  </dependencies>
</ivy-module>
----


== DSL Guide

The intrepid plugin adds several gloss:domain-specific-language[] (DSL) elements.

[[_repositories]]
=== repositories

This DSL element isn't actually part of the +intrepid+ plugin, but will likely need to be configured
in your build script, and usually appears near the top of the file.  (See
http://www.gradle.org/docs/1.4/userguide/userguide_single.html#N10607[repositories] in the Gradle
documentation.) This element should be placed in the root of your build script--that means, outside of any
other DSL elements such as <<_sourceDependencies>>). For example:

[source,groovy]
----
repositories.ivy {
    url "http://artifactory-server/artifactory/my-repo"
    credentials {
        username "user"
        password "password"
    }
}
----

This +repositories+ block will configure <<_sourceDependencies>> and <<_packedDependencies>>. You can configure it using any of the methods in methods in the Gradle link:http://gradle.org/docs/1.4/javadoc/org/gradle/api/artifacts/dsl/RepositoryHandler.html[RepositoryHandler] (e.g. Maven, Ivy or file-system) but the publishing of packages using +intrepid+ only supports Ivy so you'll probably only have artifacts available in an Ivy repository.

[[_configurationSetTypes]]
=== configurationSetTypes

This DSL block is used in combination with the <<_configurationSets>> block to provide a convenient way to define
several related gloss:configuration[]s in your project, and their mapping to configurations in other modules, following
common patterns.  For background information about configurations and configuration mapping, see the
link:overview.html#_gradle_module_concepts[] overview and the link:workflows.html#_configurations[] section of the
link:workflows.html[] page.

A gloss:configuration-set-type[] defines a pattern for related named configurations and a pattern for mapping those
configurations to corresponding configurations in other modules for <<_packedDependencies>> and <<_sourceDependencies>>.
(A gloss:configuration-set[] actually creates those configurations in a project, optionally extending the naming
pattern, so that a project can have several different parts following the same pattern--for example, client and server
executables.)

Often you will not need to use this block in your build file, because the gloss:holygradle[] automatically adds several
configuration set types which are commonly useful for web and Windows native applications.  You can however remove or
replace those types or add your own.

TIP: You can print a given configuration set type such as +configurationSetTypes.LIB+ using the normal Groovy +println+
method to see information about what it defines.

==== Pre-defined Configuration Set Types

This section describes the types pre-defined by the Holy Gradle.

===== Naming Pattern

The naming pattern is based on the idea that there are several concepts relevant to the files which make up a
typical non-Java module.  One word is used for each such concept or "axis" and, unlike Java which uses +camelCaseWords+,
the axes are separated by underscores.  This is so that it is easy for non-Java build tools to construct
configuration names from pieces; but +camelCase+ may be used within the value for some axis.

Some axes are optional, and the Platform and Configuration axes also have a "combined" value `common`, for files such as
C++ headers, which are the same across Platform and Configuration.

// NOTE: Need leading {empty} here so that the '[]' aren't interpreted as paragraph styles.  Can't use leading space
// or it's interpreted as literal text and comes out all monospace.  Also need custom {undsc} attribute and double (as
// opposed to single) quotes to get formatting right.
====
{empty}[_Testing_ "+{undsc}+"] +
{empty}[_Subcomponent_ "+{undsc}+"] +
{empty} _Stage_ +
{empty}[ { ["+{undsc}+" _Platform_] ["+{undsc}+" _BuildType_] | "+{undsc}common+" } ]
====

For example, `import_x64_Release`, or `test_server_runtime_x64_Release`.

Testing::
    This axis is related to the testing of the module:
+
* No value for this axis means the configuration covers the default, production use of the module.
* +test+: Parts used for unit testing the module.
* +integTest+: Parts used for integration testing of the module.

Subcomponent::
    This axis indicates that your module contains several separate parts, for example matching +client+ and +server+
libraries.  There are no suggested standard values--you can use any word which describes the subcomponent.  If you
need more than one work, use +camelCase+.
Stage::
    This refers to stages of the software lifecycle.
+
* `import`: Files needed from module when you want to build some other module which uses it.
* `runtime`: Files needed from the module at runtime.
* `debugging`: Files only needed if/when you want to debug a running application (or a crash dump).

Platform::
    This axis covers the Visual Studio / MSBuild "Platform": "Win32" or "x64".  Non-C++ and other platform-neutral
modules would omit this axis.
Configuration::
    For modules built with Visual Studio / MSBuild, this covers the "Configuration": "Debug" or "Release".  Non-C++
modules will usually still include this axis; for example, a JavaScript library would have minified JS in its
"Release" built type, whereas "Debug" would have the non-minified JS.

These configuration set types also define a private configuration called +build+.  Its purpose is to map to
configurations in other modules in cases where those files are needed to build this module, but are not needed by
other modules which use this one.  Typically it maps to

* build tools;
* `import_*` in other modules, if the interface of that module should _not_ be exposed from this module.

===== Default Visual Studio Types

There are several configuration set types for Visual Studio solutions which are mainly C++-style projects.  These
types have a naming pattern which defines the _Stage_, _Platform_, and _Configuration_ axes; the _Testing_ and
_Subcomponent_ axes can be added by a specific configuration set.

* LIB: static libraries, or similar things which do not themselves have runtime files.

* DLL: dynamic libraries, or similar things which have runtime files and are used by other libraries or executables

* EXE: dynamic libraries, or similar things which have runtime files and are executable themselves, instead of being
used by other modules.

These configuration set types define configuration name parts, "extends from" relationships, and contents as follows.

[options="header",cols="2,1,3"]
|====
|Name |Extends |Contains

|`build`
|nothing
|nothing, because this configuration is private

|`import_common`
|nothing
|Platform- and Configuration-independent files which other modules need to build against this one.

|`import_x64_Release` +
`import_x64_Debug` +
`import_Win32_Release` +
`import_Win32_Debug`
|`import_common`
|Platform- and Configuration-specific files which other modules need to build against this one.

|`runtime_x64_Release` +
`runtime_x64_Debug` +
`runtime_Win32_Release` +
`runtime_Win32_Debug`
|nothing
|Platform- and Configuration-specific files which other modules need at runtime to use this one.

|`debugging_x64_Release` +
`debugging_x64_Debug` +
`debugging_Win32_Release` +
`debugging_Win32_Debug`
|nothing
|Platform- and Configuration-specific files which other modules need to debug against this one.

|====

===== LIB

This type is for static libraries built with the typical Visual Studio +Platform+ values of +x64+ and +Win32+,
and +Configuration+ values of +Debug+ and +Release+.  There are also types called

* `LIB_RELEASE`, which does not include any of the names with `Debug` in them;
* `LIB_64`, which does not include any of the names with `Win32` in them;
* `LIB_64_RELEASE`, which does not include any of the names with `Win32` or `Debug` in them.

The configurations are intended to contain the following kinds of files when your module is published, as controlled by
the <<_packageArtifacts>> block.

[options="header",cols="2,4"]
|====
|Name |Contains 

|`build`
|nothing, because this configuration is private

|`import_common`
a|For a Windows static library, this configuration might include

* header files
* Visual Studio property sheets (for setting up include/link paths)

|`import_x64_Release` +
`import_x64_Debug` +
`import_Win32_Release` +
`import_Win32_Debug`
|`.lib` files, and also `.pdb` files (because PDBs for static libraries are linked into the PDBs for DLLs/EXEs which
use them, and are not needed at debugging time)

|`runtime_x64_Release` +
`runtime_x64_Debug` +
`runtime_Win32_Release` +
`runtime_Win32_Debug`
|nothing

|`debugging_x64_Release` +
`debugging_x64_Debug` +
`debugging_Win32_Release` +
`debugging_Win32_Debug`
|nothing

|====

===== DLL

This type is for dynamic libraries built with the typical Visual Studio +Platform+ values of +x64+ and +Win32+,
and +Configuration+ values of +Debug+ and +Release+.  There are also types called

* `DLL_RELEASE`, which does not include any of the names with `Debug` in them;
* `DLL_64`, which does not include any of the names with `Win32` in them;
* `DLL_64_RELEASE`, which does not include any of the names with `Win32` or `Debug` in them.

These types are also suitable for executables which are used like libraries, in that your module needs some kind of
header to use them and/or they are not run independently.  For example, COM singletons are build as EXEs but can be
used by libraries, which need "+.idl+" files to access them.  The configurations are intended to contain the
following kinds of files when your module is published, as controlled by the <<_packageArtifacts>> block.

[options="header",cols="2,4"]
|====
|Name |Contains 

|`build`
|nothing, because this configuration is private

|`import_common`
a|For a Windows dynamic library, this configuration might include

* header files
* +.idl+ files
* Visual Studio property sheets (for setting up include/link paths)

|`import_x64_Release` +
`import_x64_Debug` +
`import_Win32_Release` +
`import_Win32_Debug`
|`.lib` files

|`runtime_x64_Release` +
`runtime_x64_Debug` +
`runtime_Win32_Release` +
`runtime_Win32_Debug`
|`.dll` files, and any `.exe` or other "plugin-style" executable files

|`debugging_x64_Release` +
`debugging_x64_Debug` +
`debugging_Win32_Release` +
`debugging_Win32_Debug`
|`.pdb` files

|====

===== EXE

This type is for executables built with the typical Visual Studio +Platform+ values of +x64+ and +Win32+, and
+Configuration+ values of +Debug+ and +Release+.  There are also types called

* `EXE_RELEASE`, which does not include any of the names with `Debug` in them;
* `EXE_64`, which does not include any of the names with `Win32` in them;
* `EXE_64_RELEASE`, which does not include any of the names with `Win32` or `Debug` in them.

These types are also suitable for executables which are used like libraries, in that your module needs some kind of
header to use them and/or they are not run independently.  For example, COM singletons are build as EXEs but can be
used by libraries, which need "+.idl+" files to access them.  The configurations are intended to contain the
following kinds of files when your module is published, as controlled by the <<_packageArtifacts>> block.

[options="header",cols="2,4"]
|====
|Name |Contains 

|`build`
|nothing, because this configuration is private

|`import_common`
|nothing

|`import_x64_Release` +
`import_x64_Debug` +
`import_Win32_Release` +
`import_Win32_Debug`
|nothing

|`runtime_x64_Release` +
`runtime_x64_Debug` +
`runtime_Win32_Release` +
`runtime_Win32_Debug`
|`.exe` files

|`debugging_x64_Release` +
`debugging_x64_Debug` +
`debugging_Win32_Release` +
`debugging_Win32_Debug`
|`.pdb` files

|====

===== Default Web Types

There is currently only one configuration set type intended for web applications.  The naming pattern defines the _Stage_ and _Configuration_ axes, and omits the _Platform_ axis; the _Testing_ and
_Subcomponent_ axes can be added by a specific configuration set.

* WEB_LIB: web application components, for use as part of a larger application, containing JavaScript, HTML, CSS and
related files.

This configuration set type defines configuration name parts, "extends from" relationships, and contents as follows.

[options="header",cols="2,1,3"]
|====
|Name |Extends |Contains

|`build`
|nothing
|nothing, because this configuration is private

|`import_common`
|nothing
|Configuration-independent files which other modules need to build against this one.

|`import_Release` +
`import_Debug`
|`import_common`
|Configuration-specific files which other modules need to build against this one.

|`runtime_Release` +
`runtime_Debug`
|nothing
|Configuration-specific files which other modules need at runtime to use this one.

|`debugging_Release` +
`debugging_Debug`
|nothing
|Configuration-specific files which other modules need to debug against this one.

|====

===== WEB_LIB

This type is for web application components, for use as part of a larger application, containing JavaScript, HTML,
CSS and related files.

[options="header",cols="2,4"]
|====
|Name |Contains 

|`build`
|nothing, because this configuration is private

|`import_common`
|Build scripts or other files which other modules need to build against this one.

|`import_Release` +
`import_Debug`
|Configuration-specific build scripts or files which other modules need to build against this one.

|`runtime_common`
|HTML and/or similar content which does _not_ differ between Release (minified) and Debug (non-minified).

|`runtime_Release` +
`runtime_Debug`
|JavaScript, CSS, XSLT, and/or similar content which differs between Release (minified) and Debug (non-minified).

|`debugging_common`
|Debugging support files which do _not_ differ between Release (minified) and Debug (non-minified).

|`debugging_Release` +
`debugging_Debug`
|Source maps and/or other debugging support files which differ between Release (minified) and Debug (non-minified).

|====

===== Configuration Mapping Rules

These configuration set types can be passed to the +configurationSet+ method of <<_sourceDependencies>>
(<<_sourceDependencies_configurationSet>>) or <<_packedDependencies>> (<<_packedDependencies_configurationSet>>)
and the Holy Gradle will automatically create mappings between configurations, according to the following rules.

* The `runtime_*` and `debugging_*` configurations in a dependency are always mapped from the corresponding
configurations in this module.  That is, `runtime_Win32_Debug->runtime_Win32_Debug`,
`runtime_Win32_Release->runtime_Win32_Release`, and so on.  This is true even for static libraries because they
can have runtime dependencies on DLLs.

* The `import_common` configuration does not need to be mapped between modules because other modules are only
expected to use the `import_*` configurations (`import_Win32_Debug` and so on), and those configurations will
include everything in the other module's `import_common`, because each `import_*` configuration extends
`import_common`.

* The `import_*` configurations in a dependency may be

** mapped from the corresponding public configurations in this module (`import_x64_Release->import_x64_Release`
and so on) if

*** either the interfaces of that module should be exposed from this module;

*** or both this module and the dependency are static libraries, because in that case another module which links
against this one will also have to link against the dependency;

** mapped from the private `build` configurations in this module (`build->import_x64_Release` and so on) if the
interfaces of that module should be encapsulated within this module;

** not mapped at all, if the dependency is an EXE-style module, because they do not have build-time interfaces.

The rule for the `import_*` configurations can also be represented by the following table.  The From/To columns
are the configuration set type for the source and destination of the mapping.  The `export:` column indicates
what value for that option (default +false+) is passed to the +configurationSet+ method of +sourceDependencies+
++_packedDependencies++.

[width="60%",cols="1,1,1,2",options="header"]
|====
|From |To |`export:` |Map to `import_*`?

.5+|LIB .2+|LIB |`false` |from same
|`true` |from same
.2+|DLL |`false` |from `build`
|`true` |from same
|EXE |n/a |no
.5+|DLL .2+|LIB |`false` |from `build`
|`true` |from same
.2+|DLL |`false` |from `build`
|`true` |from same
|EXE |n/a |no
.3+|EXE |LIB |n/a |no
|DLL |n/a |no
|EXE |n/a |no

|====

==== User-defined Configuration Set Types

It is possible to define your own configuration set types, though the ways of doing this are currently not documented.
Please look at the source for the interfaces +ConfigurationSetType+ and +ConfigurationSet+, and the classes which
implement them.

[[_configurationSets]]
=== configurationSets

This DSL block is used in combination with the <<_configurationSetTypes>> block to provide a convenient way to define
several related gloss:configuration[]s in your project, and their mapping to configurations in other modules, following
common patterns.  For background information about configurations and configuration mapping, see the
link:overview.html#_gradle_module_concepts[] overview and the link:workflows.html#_configurations[] section of the
link:workflows.html[] page

You will commonly use this block in your +build.gradle+ file although it is not required: you can define individual
configurations yourself, but the configuration mapping in source and packed dependency definitions may be more verbose.
You can also define both configuration sets and individual configurations.

This is a container for configuration set objects. The first level below +configurationSets+ defines the names of the individual configuration sets.  The name of the set is only used to refer to this set elsewhere in the build script; it does not automatically appear in the configuration names.  For example:

[source,groovy]
----
configurationSets {
    main {
        type configurationSetTypes.DLL_64
    }
    test {
        prefix "test"
        type configurationSetTypes.EXE_64
    }
}
----

The above example is equivalent to a +configurations+ block like the following.

[source,groovy]
----
configuration {
    // "main" configuration set
    build { visible = false }
    import_common
    import_x64_Release.extendsFrom import_common
    import_x64_Debug.extendsFrom import_common
    // ...
    runtime_x64_Release
    // ...
    debugging_x64_Release
    // ...

    // "test" configuration set
    test_build { visible = false }
    test_import_common
    test_import_x64_Release.extendsFrom import_common
    test_import_x64_Debug.extendsFrom import_common
    // ...
    test_runtime_x64_Release
    // ...
    test_debugging_x64_Release
    // ...
}
----

[[_configurationSets_type]]
==== type

This method takes one parameter, the configuration set type for this configuration set.  For the pre-defined types,
the names of the configurations in the set will be those from the type, with the <<_configurationSets_prefix>> added at
the beginning.

-> You must call this method exacly once.


[[_configurationSets_prefix]]
==== prefix

This method takes one parameter, a string prefix to be added to all names from the <<_configurationSets_type>>.  If this
method is not called for a configuration set, the names from its type will be used directly.  If you have more than one
configuration set of the same or similar types in your build script, you will probably have to use a prefix on all but
one of them to avoid configuration name overlaps.

-> Call this method at most once.

[[_configurationSets_configurationSet]]
==== Configuration Set Methods

Configuration sets themselves have methods which may be useful in your build script.

[[_configurationSets_configurationSet_type]]
===== type

This property returns the configuration set type for this set.

[[_configurationSets_configurationSet_axes]]
===== axes

This property returns a map with

* keys which are the names of each axis used in the configuration set type; and
* values which are the set of values for that axis defined by the type.

[[_configurationSets_configurationSet_configurationNames]]
===== configurationNames

This property returns a map with

* keys which are maps of name-value pairs for each axis used in the configuration set type; and
* values which are the names of the corresponding configuration defined by this set.

[[_configurationSets_configurationSet_getConfigurations]]
===== getConfigurations

This method takes a Gradle https://docs.gradle.org/1.4/javadoc/index.html?org/gradle/api/Project.html[Project] object,
creates the +Configuration+ objects for the names defined by this set (if they do not already exist), and returns a map
with

* keys which are maps of name-value pairs for each axis used in the configuration set type; and
* values which are the corresponding +Configuration+ objects in the given +Project+.


=== dependenciesSettings

This object has settings which apply to all dependencies.

[source,groovy]
----
dependenciesSettings {
    defaultFailOnVersionConflict = false // defaults to true
}
----


==== defaultFailOnVersionConflict

If this flag is true, Intrepid will call +configuration.resolutionStrategy.failOnVersionConflict()+ for each configuration which is created.  This is in contrast to the default Gradle behaviour, which allows conflicts and resolves them according to configurable strategies.  To turn off this default behaviour, set the property to +false+.  This behaviour is implemented in this way because there is no Gradle mechanism to revert to allowing resolution of version conflicts after +failOnVersionConflict()+ has been called.

This value can be set in each project in a multi-project build.  If it's not set in a sub-project, that project will use the value from the root project; failing that, it defaults to +true+.

[[_sourceDependencies]]
=== sourceDependencies
This is a container for source-dependency objects. The first level below +sourceDependencies+ defines the names of the individual source code dependencies e.g.

[source,groovy]
----
sourceDependencies {
    foo.hg "http://path/to/hg/repo"
    bar {
        svn "http://path/to/svn/repo"
    }
}
----

declares that there are two source-code dependencies and they should be retrieved to the directories '<workspace>/foo' and '<workspace>/bar' respectively.

==== Relative Paths

Source dependencies and packed dependencies are now specified as relative paths rather than always being immediate subdirectories of the workspace. See <<_relative_paths>>.

==== Credentials

By default, intrepid can only fetch source from repositories which do not require authentication.  If the project also has the link:plugin-my-credentials.html[] applied, it will use passwords cached in Windows Credential Manager to access Mercurial and Subversion repositories.  If cloning, checking out, or exporting a repository for which no password is already cached, the plugin will initialise the cached password for that repository using the value stored under +"Intrepid - Domain Credentials"+ (the default username and password managed by link:plugin-my-credentials.html[]).

==== hg

This method takes one parameter - the URL of the Mercurial repository to clone.

You can optionally specify a particular Mercurial revision after an '@' character e.g.

[source,groovy]
----
foo.hg "http://path/to/foo@384039b6ec8b44cec59dc48b264056882f60b7a7"
----

This will result in a clone that has been updated to the specific Mercurial revision.

After the source dependency has been retrieved you may make local modifications or update to a different revision and rerunning +fetchAllDependencies+ will have no effect on your local copy.

-> Call this method at most once.

-> You must call one of +hg+ or +svn+.

NOTE: If the Mercurial repository has an +https:+ URL, some setup may be required.  See
link:troubleshooting.html#_mercurial_https_access[].

==== svn

This method takes one parameter - the URL of the Subversion repository to checkout from.

You can optionally specify a particular SVN revision after an '@' character e.g.

[source,groovy]
----
bar.svn "http://path/to/bar@143"
----

This will result in a checkout of the repository, pinned to a specific version.

After the source dependency has been retrieved you may make local modifications or update to a different revision and rerunning +fetchAllDependencies+ will have no effect on your local copy.

-> Call this method at most once.

-> You must call one of +hg+ or +svn+.

==== branch

This is an optional property that defines which named branch of the repository to use. This is only valid for 'hg' repositories, and the default value is 'null' which equates to retrieving the default branch. This is equivalent to +hg clone http://path/to/foo --branch special foo+.

Usage:

[source,groovy]
----
sourceDependencies {
    foo {
        hg "http://path/to/foo"
        branch = "special"
    }
}
----

[[_sourceDependencies_configuration]]
==== configuration

This method defines the configuration mapping for the dependency - see the +<dependency
... conf="..."/>+ attribute in the example module descriptor above.

More details on extending configurations, and mapping sets of related configurations between modules,
can be found in the link:workflows.html#_configurations[] section of the link:workflows.html page.

You can pass any number of string parameters to this method, or call the method multiple times.

-> Call this method at least once.

[[_sourceDependencies_configurationSet]]
==== configurationSet

TODO: doc

[[_publishing]]
==== publishing

WARNING: This block is deprecated as of version link:release_notes.html#_7_7_0[], and will be removed in a future
version of the Holy Gradle.

This is like a struct which groups together a few different configuration options relating to how the source-code dependency will be referenced (in the Ivy module descriptor XML) when the consumer module is published.  The consumer module can be published as depending on the published output of a source-code dependency.

If the +publishing+ configuration is omitted then the source-code dependency will not be mentioned in the module descriptor.

This is an example of a fully-specified +publishing+ element:

[source,groovy]
----
sourceDependencies {
    dependency_module {
        svn "http://path/to/svn/repo"
        publishing {
            group "com.company.team"
            configuration "compileDebug->compileVc10Debug", "compileRelease->compileVc10Release"
            version "1.0.+"
        }
    }
}
----

NOTE: In order for dynamic version numbers to be resolved you will need to configure the <<_repositories>> element.


===== group

This method configures the group name for the dependency - see the `dependency->org` attribute in the above module descriptor.

If this method is not called then the group will default to the group specified in <<_publishPackages>>.

-> Call this method at most once.

[[_publishing_configuration]]
===== configuration

This method is the same as the <<_configuration>> method of a source dependency block.

===== version

This method defines the version number that will be used in the +dependency+ elements in the module descriptor.

You can specify an exact version number (e.g. +1.2.3.4+) or a dynamic version number (e.g. +1.2.++). The dynamic version number will be resolved to a concrete version number based on what artifacts exist in the target repository **at the time that the module is published.**

By default, if you do not specify a version, then the version used for publishing the module will also be used for the version number in the +dependency+ element in the module descriptors for source dependencies.

-> Call this method at most once.

===== usePublishedVersion

This method was removed in version 7.7.0.  The behaviour it was intended to provide -- switching
between binary and source versions of the same module -- will be provided by a better mechanism in
future.

=== sourceDependencyTasks

This container allows you to define commands to be invoked on all +sourceDependencies+.

For example:

[source,groovy]
----
sourceDependencyTasks {
    theTask {
        invoke("command", "could", "fail").failAtEnd()
        invoke("fails", "but", "dont", "care").ignoreFailures()
        invoke("failure", "is", "important").failImmediately()
        invoke("failure", "is", "important") // behaves as failImmediately
    }
}
----

The above script will define a task +theTask+ to be invoked on the current project AND all of the source dependencies that it depends on. This means that you can define a set of useful commands in your root build script and make use of them in all subprojects.

Each invocation can be configured to behave appropriately with respect to the return codes.

* +failImmediately()+ - terminate as soon as possible when any invocation's exit code is non-zero. This is the default behaviour.
* +failAtEnd()+ - after all projects have made the invocation, check for non-zero exit codes and summarise. If there were any failures then terminate here.
* +ignoreFailures()+ - ignore the exit codes.

WARNING: If your source dependency command does something which modifies the Gradle scripts (for
example, +svn update+ or +hg update+) then the new versions of the Gradle scripts will not be
applied until the next time you invoke Gradle. So for example 'gw hgUpdate buildRelease' would do
the Hg update but the build task would run according to the Gradle scripts prior to the update. So
it would be better to run these two tasks separately: 'gw hgUpdate' followed by 'gw buildRelease'.
+
If such a task fails after only some source dependencies are updated, you may be unable to run
Gradle if the +build.gradle+ files across all the projects are no longer consistent.  In that case
you must update or otherwise modify each repository until the Gradle scripts reach a consistent
state.

=== sourceControl

This DSL gives you read-only access to various properties of the source control repository for the current project e.g. protocol (hg or svn), url, revision, and whether there are any local modifications.

==== protocol

This read-only property returns a string "hg" or "svn" depending on whether this project directory is an hg clone or an svn checkout. If it is neither then "n/a" will be returned.

==== url

This read-only property returns the url for the source control repository/checkout in the project directory. Null is returned if the project directory is not under source control.

==== revision

This read-only property returns the revision for the source control repository/checkout in the project directory. Null is returned if the project directory is not under source control.

==== hasLocalChanges

This method returns a boolean indicating whether the source control repository/checkout in the project directory has any uncommitted modifications. False is returned if the project directory is not under source control.

[[_packedDependencies]]
=== packedDependencies

This is a container for packed dependency objects. The first level below +packedDependencies+ defines the names of the individual dependencies e.g.


[source,groovy]
----
packedDependencies {
    "RenderingLib" {
        dependency "com.my-company.rendering:RenderingLib:2012a2"
        configurationSet configurationSets.main, configurationSetTypes.LIB_64
    }
    "NUnit <version>" {
        dependency "org.nunit:NUnit:2.5.+"
        def testRuntimeConfs = configurationSets.test.configurationNamesMap.findAll { k, v ->
	    k[stage] == 'runtime'
	}
        configuration "${testRuntimeConfs.join(',')}->bin"
        unpackToCache = false
    }
}
----

declares two dependencies:

* +RenderingLib+ packages belonging to the configurations defined by the +LIB_64+ configuration type
should be unpacked to the central cache, and a symlink should be created at
+<workspace>/my-rendering-lib+. When this module is published, the +RenderingLib+ dependency will be
included in the module descriptor. 
* +NUnit+ packages belonging to the configuration +bin+ should be unpacked directly to the workspace
in folder called +<workspace>/NUnit 2.5.10+ (assuming that 2.5.10 is the most recent version with
the prefix "2.5").

==== Relative Paths

Source dependencies and packed dependencies are now specified as relative paths rather than always being immediate subdirectories of the workspace. See <<_relative_paths>>.

==== Using +<version>+

You can specify +<version>+ anywhere within the name of a packed dependency e.g. +"my_component-<version> blah"+. Once the version number has been resolved, the +<version>+ will be replaced with the actual version of the packed dependency that has been retrieved.

The name of the packed dependency affects:

* the path to which the dependency will be unpacked within your workspace (if +unpackToCache+ is false)
* the name of the symlink in your workspace (if +unpackToCache+ is true, which is the default)

For the example above, the workspace would look like this:

----
<workspace>
|   build.gradle
|   ...
+---RenderingLib (symlink ---> <unpack cache>/com.company.rendering/RenderingLib/2012a2)
|   ...
+---NUnit 2.5.10
    ...
----


==== dependency

This method configures the coordinates of the dependency. The single parameter must follow the pattern "<groupId>:<artifactId>:<version>" where:

* +groupId+ is an identifier (such as the name of the organisation) to disambiguate the +artifactId+. The +groupId+ can contain full-stops e.g. +org.common.util+.
* +artifactId+ is an identifier for the artifact.
* +version+ is a version number. 

WARNING: Floating version numbers (e.g. +1.2.++) are supported. (See link:http://www.gradle.org/docs/1.4/userguide/userguide_single.html#sec:dependency_resolution[how dependency resolution works].)  However, use of floating version numbers is not recommended because they are ordered lexicographically rather than numerically: that means +1.10+ comes before +1.2+, for example.

-> Call this method exactly once.

[[_packedDependencies_configuration]]
==== configuration

This method defines the mappings **from** configurations in this module **to** configurations in the dependency module. These mappings will be included in the module descriptor when this module is published. The **to** configurations also determine which packages from the dependency artifact will be fetched and unpacked.

You can pass any number of string parameters to this method, or call the method multiple times.

Here are some examples of string parameters passed to the +configuration+ method and the resulting mappings:

===== +"my-config"+

* configuration mapping from "my-config" to "my-config"

===== `"foo->bar"`

* configuration mapping from "foo" to "bar"

===== `"foo->bar,far"`

* configuration mapping from "foo" to "bar"
* configuration mapping from "foo" to "far"

===== `"aa,bb->cc"`

* configuration mapping from "aa" to "cc"
* configuration mapping from "bb" to "cc"

===== `"aa,bb->cc,dd"`

* configuration mapping from "aa" to "cc"
* configuration mapping from "aa" to "dd"
* configuration mapping from "bb" to "cc"
* configuration mapping from "bb" to "dd"

-> Call this method at least once.

[[_packedDependencies_configurationSet]]
==== configurationSet

===== Private dependencies

Sometimes you may want to use the gloss:holygradle[] to fetch build tools -- for example, Doxygen to document C++ code.
This is different from when your module depends on another library module, because usually another developer will not
need these build tools to use your module.  In cases like these, you can map the dependency from a _private_
gloss:configuration[].  This means the configuration is marked as +visible="false"+ in the gloss:ivy-xml[], which means
some tools will ignore it in default cases.  You can do this when you specify a configuration in your module:

[source,groovy]
----
configurations {
    build { visible = false } // private
    other // public
}
----

Also, with the Holy Gradle, any configurations with a name beginning with "+private+" will be marked private.

[source,groovy]
----
configurations {
    privateBuild // private
    other // public
}
----

==== unpackToCache

This property defines whether the dependency should be unpacked to the central cache for unpacked dependencies, or unpacked directly to the workspace.

-> Default value: **true**

==== noCreateSymlinkToCache()

Calling this method on a packed dependency causes the +rebuildSymlinks+ and +deleteSymlinks+ task to ignore it.  This allows you to create your own folder or symlink in the appropriate location, to replace a packed dependency with, for example, a locally-built version.

It is expected that developers will normally only use this method temporarily in their local check-out, and not commit it to shared version-controlled source.  If this method is called on a packed dependency, then attempting to publish the containing project will throw an exception, because Gradle cannot know the real version of the dependency.

==== readonly

This property determines whether the unpacked dependency directory (and all subdirectories and files) should be set to read-only. This can help to prevent the unpacked dependency files being unintentionally modified.

Note: this will only be done if +applyUpToDateChecks+ is false.

-> Default value: **true**

==== applyUpToDateChecks

This property determine whether +fetchAllDependencies+ should perform full up-to-date checks to compare the dependency zip files with the target directory. This will take much longer to execute, but avoids any possibility that the unpacked dependencies have been modified.

-> Default value: **false**

=== packedDependenciesSettings

This DSL block contains settings which control how packed dependencies are unpacked.

==== Unpack cache

The default location for the unpacked dependency cache is +<Gradle User Home dir>/unpackCache+.
You can change the location of your link:first_steps.html#gradle_user_home[Gradle User Home]
directory.  If you want more specific control then that can be achieved with the following piece
of DSL.

[source,groovy]
----
packedDependenciesSettings {
    unpackedDependenciesCacheDir = "d:/dep_cache"
}
----

If this value is set in the root project, it will affect all sub-projects unless they override it.

Since this specifies a machine-specific location you should probably avoid including the path in a build script that
will be shared with other developers. You may wish to use a link:custom-gradle.html#user_gradle[user.gradle] file or
link:http://www.gradle.org/docs/1.4/userguide/userguide_single.html#properties[gradle.properties] file to configure the
path.

[[useRelativePathFromIvyXml]]
==== Relative paths for transitive dependencies

By default, when a packed dependency has further transitive dependencies, the unpacked directories/symlinks for those
will appear next to the packed dependency.

Previous versions of the Holy Gradle allowed published modules to specify the relative location where each transitive
packed dependency should appear.  This design caused various problems, as follows.

* If a packed dependency is used in multiple places in the dependency graph, it would require extra effort to create a
symlink at each location, and waste space if +unpackToCache = false+ is used.
* If relative paths points to child folders of dependencies, arbitrarily long paths may be created, causing problems
with Windows' maximum path length of 260 characters.
* If relative paths points to child folders of dependencies, and the same dependencies are used in separate projects,
and at least one of those projects forces a dependency to resolve to a different version, there is no way to create a
correct set of symlinks (in the default case where +unpackToCache = true+).

In practice, all uses had a relative path of +"../_module_name_"+, so this is now the default, and the previous
behaviour will be removed in a future version, provided no problems are found with this approach.
For now, the previous behaviour can be re-activated with the following bit of DSL.

[source,groovy]
----
packedDependenciesSettings {
    useRelativePathFromIvyXml = true
}
----

If this value is set in the root project, it will affect all sub-projects unless they override it.

=== symlinks

This extension allows you to define symlinks for +packedDependencies+ or +sourceDependencies+ e.g. this extract of build script for a module named +consumer_module+

[source,groovy]
----
symlinks {
    to "dependency_module", "dependency_module/common"
}
----

will result in symlinks as follows:

----
<workspace>
|   build.gradle
|
+---consumer_module
|   |   build.gradle
|   |   common            (symlink --------|
|   |   dependency_module (symlink ---|    |
|   +---src                           |    |
|   |   ...                           |    |
|   +---lib                           |    |
|       ...                           |    |
|                                     |    |
+---dependency_module   <-------------|    |
    |   build.gradle                       |
    +---src                                |
    |   ...                                |
    +---common  <--------------------------|
----


==== to

This method takes one or more parameters. Each parameter defines a location in the retrieved source-code dependency folder. The name of the resulting symlink will always correspond to the last component of the path argument.

-> Call this method any number of times with any number of arguments.

[[_packageArtifacts]]
=== packageArtifacts

This is a container for packages. The first level below +packageArtifacts+ defines the names of the individual packages e.g.

[source,groovy]
----
packageArtifacts {   
    import_common.include "src/**/*.h"
    configurationSets.main.axes['Configuration'].each { conf ->
        "${conf}Exe" {
            configuration = "runtime_x64_$conf"
            include "bin/$conf/*.exe"
            exclude "**/helper.exe"
        }
        "${conf}Pdb" {
            configuration = "debugging_x64_$conf"
            include "bin/$conf/*.pdb"
        }
    }
    docs {
        from "docs/output"
        to "api"
        include "aaa/a.txt", "bbb/b.txt"
    }
}
----

defines 6 packages: +import_common+, +docs+, +DebugExe+, +DebugPdb+, +ReleaseExe+ and +ReleasePdb+.

Each package:
* is a zip-file which will be created at publish-time;
* defines, implicitly or explicitly, which configuration it belongs to;
* will be referenced in the module descriptor (gloss:ivy-xml[]).

==== configuration

This property defines the configuration that the package belongs to. For example look at the +conf+ attribute below:

[source,groovy]
----
<publications>
    <artifact name="example-import_x64_Debug" type="zip" ext="zip" conf="import_x64_Debug"/>
    ...
</publications>
----


You do not have to explicitly set the configuration if the name of the package already matches the name of the configuration.

-> Default value: **package name**

==== include

This method defines file-path patterns to **include** in the package, subject to those files not being excluded by the <<_exclude>> patterns.

You can pass any number of string parameters to this method, or call the method multiple times.

-> Call this method at least once.

==== exclude

This method defines file-path patterns to **exclude** from the package. This will take priority over any <<_include>> patterns.

Some patterns will be excluded by default: +.gradle+, +packages/ivy.xml+, +packages/*.zip+

You can pass any number of string parameters to this method, or call the method multiple times.

-> Call this method any number of times.

==== from and to

These methods allow you to change the path to files that you include in a package. By default the packaging process behaves as if both +from+ and +to+ had been set to +"."+.

In the example above the files +docs/output/aaa/a.txt+ and +docs/output/bbb/b.txt+ will be included in the +docs+ package, but their path will be +api/aaa/a.txt+ and +api/bbb/b.txt+.

You can use multiple +from/to+ combinations in the same package e.g.

[source,groovy]
----
packageArtifacts {   
    docs {
        from ("component1/docs/output") {
            to "api"
            include "*.chm"
        }
        from ("component2/docs/output") {
            to "api"
            include "*.chm"
        }
    }
}
----


-> Call +from+ any number of times. Call +to+ at most once in each context.

==== includeTextFile

This method allows you to dynamically create a text file to be included in the package. e.g.

[source,groovy]
----
packageArtifacts {
    preBuiltArtifacts {
        includeTextFile("readme.txt") {
            add "the first line with a ${variable}"
            add "as many lines as you want"
            add """a triple-quoted string
which can span multiple lines
and is a standard feature of the Groovy language"""
        }
    }
}
----


===== add

This method adds a line of text to the text file. 

-> Call this method any number of times.

[[_includeBuildScript]]
==== includeBuildScript

This extension allows you to dynamically create a build script to be included in the package. There is support for taking the +sourceDependencies+ already defined and converting them to pinned source dependencies or to +packedDependencies+. This facilitates the creation of source and binary 'meta-packages' for releases.


[source,groovy]
----
packageArtifacts {
    pinnedSource {
        include "gradle/**", "gw.bat", "gradle.properties"
        includeBuildScript {
            add "// This text goes at the top."
            addPinnedSourceDependency "*"
            add "// This text goes at the bottom."
        }
    }
    preBuiltArtifacts {
        include "gradle/**", "gw.bat"
        includeBuildScript {
            addIvyRepository "http://path/to/repo"
            addPackedDependency "foo", "fromConf1->toConf1", "fromConf2->toConf2"
        }
    }
}
----


===== createDefaultSettingsFile

If this property is true, and +includeBuildScript+ is called, but +includeSettingsFile+ is not, then
the plugin will add a default +settings.gradle+ file to the package.  If the property is false then,
in that case, the package will have no settings file.  That may lead to unexpected behaviour when
the package is used, if it is unzipped in a location where some ancestor folder has a settings
file.  See Gradle documentation for the
https://docs.gradle.org/1.4/userguide/build_lifecycle.html#sec:settings_file[Settings file],
https://docs.gradle.org/1.4/userguide/build_lifecycle.html#sec:initialization[Initialization] and
the +-u+ / +--no-search-upwards+
https://docs.gradle.org/1.4/userguide/gradle_command_line.html[command line] option.

This property is true by default.

===== add

This method allows you to include arbitrary text in the generated build script. If you call this
before any call to <<_addPinnedSourceDependency>> or <<_addPackedDependency>> then the text will
appear at the top of the build script. Otherwise it will appear at the bottom.

-> Call this method any number of times.

[[_addPinnedSourceDependency]]
===== addPinnedSourceDependency

This method allows you to select source dependencies to be included in the generated build script, pinned to the current source-control revision.

This method takes any number of parameters which refer to source dependencies in the current project, or any sub-project in a multi-project workspace. Each parameter is the name of the source dependency to include.

-> Call this method any number of times.

Note: This method used to support a wildcard syntax but no longer does.  To add all source
dependencies from all projects, you can use the following code inside an <<_includeBuildScript>>
block.

[source,groovy]
----
gradle.projectsEvaluated {
    allprojects { sourceDependencies.each { addPinnedSourceDependency it }
}
----

[[_addPackedDependency]]
===== addPackedDependency

This method allows you to specify dependencies to be included in the generated build script as +packedDependencies+ i.e. to retrieve pre-built artifacts instead of the source code repository.

The first parameter of this method can represent several different things. It can be:

* the name of the source dependency (without any path) in the current project, or any sub-project in a multi-project workspace.
* the name of the packed dependency (without any path) in the current project, or any sub-project in a multi-project workspace.
* a fully qualified dependency coordinate e.g. "org:my-module:1.0.2"

All subsequent parameters are configurations which indicate which parts of the packed dependency should be retrieved. These parameters follow the same format as is used in +packedDependencies+ e.g. "fromConf->toConf"

-> Call this method any number of times.

===== addIvyRepository

This method allows you to specify an ivy repository url which will be included in the build script like this:

[source,groovy]
----
repositories.ivy {
    credentials {
        username my.username()
        password my.password()
    }
    url <the url>
}
----


This is useful if you call +addPackedDependency+ because in order to retrieve the published artifacts you will need to specify the repository to retrieve them from.

You can also pass a second parameter to this method, which gets used as follows: +my.username(<param>)+ and +my.password(<param>)+.

-> Call this method any number of times.

===== generateSettingsFileForSubprojects

This property allows you to define whether a settings file should be generated by the build script,
listing all the source dependencies added by <<_addPinnedSourceDependency>>.  If the settings file
is generated, then the +build.gradle+ files from those source dependencies will be included in the
multi-project build of the generated build script.  If not, they will just be present as source code
but ignored by the Gradle build.

-> Default value: **true**

[[_publishPackages]]
=== publishPackages

This structure contains a few elements for configuring the publish settings for the module. For example:

[source,groovy]
----
publishPackages {
    group "com.company.team"
    nextVersionNumberAutoIncrementFile "next_version.txt"    
    repositories.ivy {
        credentials {
            username "user"
            password "password"
        }
        url "http://artifactory-server/artifactory/my-repo/"
    }
}
----

defines that when this module is published then:

* the group name will be "com.company.team";
* the version number will be read from the text file +next_version.txt+;
* the repository to publish to and the necessary credentials are as stated.

The name of the module is by default taken from the folder which contains the +build.gradle+ file.  Since version 7.3.0,
you can override this for the root project in +settings.gradle+ like this:

[source,groovy]
----
rootProject.name = "my_module"
----

You may want the group value to identify your entire organisation, or you may want to add sub-levels for separate
departments or teams.  The latter makes it easier to tell who is responsible for a published module, and allows you to
set up permissions in a repository server to allow only the relevant team to publish modules with that group value to
shared repositories.

When published, the module descriptor would look something like this:

[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<ivy-module version="2.0">
  <info organisation="com.company.team" module="example" revision="1.2.3.4" status="release" publication="20121115134228"/>
  <configurations>...</configurations>
  <publications>...</publications>
  <dependencies>...</dependencies>
</ivy-module>
----

WARNING: The group and version methods in this block are not yet deprecated but are likely to be
removed in a future version of the Holy Gradle.  Instead, you should just set the group and version
at the top level of the file, near the beginning, as shown in the example build script at the top of
this page.  That example shows how to set the version from an environment variable, like
<<_nextVersionNumberEnvironmentVariable>>; the other methods <<_nextVersionNumber>> and
<<_nextVersionNumberAutoIncrementFile>> have not been used in practice.

==== group

WARNING: This method is not yet deprecated but is likely to be removed in future--see above. 

This method defines the group name for the published artifacts. It will determine part of the URL to the artifacts once they are published, and also determines what goes in the `info->organisation` attribute in the module descriptor above. The group is often based on the name of the organisation, and helps to disambiguate modules with the same name from different organisations.

Calling this method has the same effect as setting the link:http://gradle.org/docs/1.4/dsl/org.gradle.api.Project.html#org.gradle.api.Project:group[group] property on the link:http://gradle.org/docs/1.4/dsl/org.gradle.api.Project.html[Project].

-> Call this method exactly once.

[[_nextVersionNumber]]
==== nextVersionNumber

WARNING: This method is not yet deprecated but is likely to be removed in future--see above. 

This method defines the version number for the published artifacts. This will determine part of the URL to the artifacts once they are published, and also determines what goes in the `info->revision` attribute in the module descriptor above.

There are two variant of this method: one taking a single string parameter, and another taking a closure which should return a string value.
 
Calling this method has the same effect as setting the link:http://gradle.org/docs/1.4/dsl/org.gradle.api.Project.html#org.gradle.api.Project:version[version] property on the link:http://gradle.org/docs/1.4/dsl/org.gradle.api.Project.html[Project].

-> Call one of +nextVersionNumber+, +nextVersionNumberAutoIncrementFile+ and +nextVersionNumberEnvironmentVariable+

[[_nextVersionNumberAutoIncrementFile]]
==== nextVersionNumberAutoIncrementFile

WARNING: This method is not yet deprecated but is likely to be removed in future--see above. 

This method has the same effect as <<_nextVersionNumber>> with a few important differences:

* the single string parameter defines a relative path to a file containing the next version number
* once the module has been successfully published the last component of the version number in the file will automatically be incremented

-> Call one of +nextVersionNumber+, +nextVersionNumberAutoIncrementFile+ and +nextVersionNumberEnvironmentVariable+

[[_nextVersionNumberEnvironmentVariable]]
==== nextVersionNumberEnvironmentVariable

WARNING: This method is not yet deprecated but is likely to be removed in future--see above. 

This method has the same effect as <<_nextVersionNumber>> except that the single string parameter defines the name of an environment variable which contains the version number. This may be useful if, for example, your autobuild already has a notion of version number and is invoking the +publish+ task.

-> Call one of +nextVersionNumber+, +nextVersionNumberAutoIncrementFile+ and +nextVersionNumberEnvironmentVariable+

==== repositories

This method has the same type as the link:http://gradle.org/docs/1.4/dsl/org.gradle.api.Project.html#org.gradle.api.Project:repositories(groovy.lang.Closure)[repositories] method on the link:http://gradle.org/docs/1.4/dsl/org.gradle.api.Project.html[Project]. However, only publishing to **Ivy repositories** is supported. This is because Ivy supports publishing multiple artifacts, which is not currently supported by the Maven publishing functionality provided by Gradle.

-> Minimal usage:

[source,groovy]
----
repositories.ivy {
    url "http://artifactory-server/artifactory/my-repo/"
    credentials {
        username "user"
        password "password"
    }
}
----

If your repository supports anonymous publishing (which is not recommended) then you could omit the +credentials+ section. Note that it is recommended that you use the link:plugin-my-credentials.html[] rather than hard-coding credentials.

== Tasks

See link:http://www.gradle.org/docs/1.4/userguide/userguide_single.html#tutorial_gradle_command_line[using the Gradle command line] for general information on invoking tasks.

=== fetchAllDependencies

This task retrieves all <<_packedDependencies>> and <<_sourceDependencies>> and sets up the
necessary symlinks. Symlinks are always deleted and rebuilt.

If a source-code dependency is retrieved then the +settings-subprojects.txt+ file (used by the Holy
Gradle's generated +settings.gradle+) will be updated to include the new module. Afterwards, the
plugin will attempt to automatically relaunch the task in order to allow the new module to be taken
into account and for further dependencies to be resolved. The gradle process is terminated with a
special exit code and as a result a slightly customised Gradle Wrapper re-launches the gradle
process. This slightly hacky approach has a few implications.

* Wake sure that any Gradle Wrapper you create comes from the 'custom-gradle-core' plugin's
+createWrapper+ task.  This version has special code to re-run Gradle when a new source dependency
is fetched, in case that source dependency has its own +build.gradle+.

* It is advisable to run the +fetchAllDependencies+ by itself, without any other tasks on the same
invocation.

* Usage of the daemon is automatically disabled by the customised Gradle Wrapper.

==== Transitive dependencies

This task also fetches transitive dependencies. For example, assume a module's build script declares a packed dependency on +foo+:

[source,groovy]
----
packedDependencies {
    foo {
        dependency "com.my-company.my-team:foo:1.2.3.4"
        configurationSet configurationSets.main, configurationSetTypes.DLL_64
    }
}
----

and the module descriptor for +foo+ declares a transitive dependency on +bar+ as follows:

[source,xml]
----
<ivy-module version="2.0">
  <info organisation="com.my-company.my-team" module="foo" revision="1.2.3.4" status="release" publication="20121115134228"/>
  <configurations>
    ...
    <conf name="runtime_x64_Debug" visibility="public" />
    <conf name="runtime_x64_Release" visibility="public" />
  </configurations>
  <publications>...</publications>
  <dependencies>
    <dependency org="com.company.team" name="bar" rev="9.8.7" conf="runtime_x64_Debug->runtime_x64_Debug;runtime_x64_Runtime->runtime_x64_Runtime"/>
  </dependencies>
</ivy-module>
----

and the module descriptor for +bar+ declares artifacts as follows:

[source,xml]
----
<ivy-module version="2.0">
  <info organisation="com.company.team" module="bar" revision="9.8.7" status="release" publication="20121115134228"/>
  <configurations>
    ...
    <conf name="runtime_x64_Debug" visibility="public" />
    <conf name="runtime_x64_Release" visibility="public" />
    <conf name="debugging_x64_Debug" visibility="public" />
    <conf name="debugging_x64_Release" visibility="public" />
  </configurations>
  <publications>
    ...
    <artifact name="bar-runtime_x64_Debug" type="zip" ext="zip" conf="runtime_x64_Debug"/>
    <artifact name="bar-runtime_x64_Release" type="zip" ext="zip" conf="runtime_x64_Release"/>
    <artifact name="bar-debugging_x64_Debug" type="zip" ext="zip" conf="debugging_x64_Debug"/>
    <artifact name="bar-debugging_x64_Release" type="zip" ext="zip" conf="debugging_x64_Release"/>
  </publications>
  <dependencies>...</dependencies>
</ivy-module>
----


In this example the top-level module is dependent on the configurations +runtime_x64_Debug+ and
+runtime_x64_Runtime+ of +foo+, which are then dependent on the same named configurations of
+bar+. Although +bar+ defines four artifacts, only +bar-runtime_x64_Debug+ and
+bar-runtime_x64_Release+ belong to the configurations of interest, so these will be
fetched. Finally, since both of these artifacts have the file-extension "zip" (see the
`artifact->ext` attribute in the module descriptor for +bar+) the +intrepid+ plugin assumes that
they should be unpacked to your unpacked cache, and creates a symlink from your workspace.

=== fetchFirstLevelSourceDependencies

This is like +fetchAllDependencies+ except that it is **not** recursive and **only** fetches source dependencies. This task will:

* retrieve all first-level (non-transitive) source-code module dependencies
* create/modify the +settings.gradle+ file to refer to the fetched source-code modules

Along with +collectDependencies+, this task can be useful in pre-fetching dependencies so that you can package them up and give them to a customer who doesn't have access to your network.

=== collectDependencies

This task will navigate through all of the project's dependencies. This includes
+packedDependencies+ and their transitive dependencies, Gradle plugins and all of their
dependencies. A folder named +local_artifacts+ will be created. Ivy and Maven style dependencies
will be placed in their respective subfolders. Source dependencies will be summarised in a
"build_info" folder but the source itself will not be included. Finally, the +custom-gradle+
gloss:gradle-distribution[] used by the gloss:holygradle[]'s gloss:gradle-wrapper[] will be placed in
its own subfolder.

The result is a directory which contains all packed dependencies. This is useful for pre-fetching
dependencies so that you can package them up and give them to a customer who doesn't have access to
your network.

TODO: Link to description of how local_artifacts is used.

This task is a subclass of the usual Gradle +Copy+ task, so the +destinationDir+ and other aspects
can be customised as normal.

=== zipDependencies

This task collects the same files as <<_collectdependencies>> but puts them in a ZIP file in the project root.  By
default the file is named +local_artifacts_{date}_UTC.zip+ where +{date}+ is the local machine date, converted to UTC.
This task is a subclass of the usual Gradle +Zip+ task, so the +baseName+ and other aspects can be customised as normal.

=== rebuildSymlinks

This task performs a subset of the functionality of the +fetchAllDependencies+ task - it simply rebuilds all the symlinks for all dependencies.

=== rebuildSymlinksToCache

TODO: doc

=== deleteSymlinks

This task deletes any symlinks created by +rebuildSymlinks+ or +fetchAllDependencies+. This is not a blanket deletion of all symlinks; only symlinks which **would** be created by the other tasks are deleted.

=== packageEverything

This task will create all zip-file packages that you have defined in the <<_packageArtifacts>>
section. You do not have to invoke this task prior to publishing because the <<_publish>> task
already depednds on this task. However you might wish to invoke this task in order to inspect the
resulting zip files prior to their being published. The zips will be placed in a +packages+
subdirectory of the module.

If you are testing the packaging, you may also wish to run the standard Gradle task,
+generateIvyModuleDescriptor+.  This will create the gloss:ivy-xml[] for your module in
+${project.buildDir}/publications/ivy/ivy.xml+.

=== publish

This task publishes the artifacts of your module:

* creates all zip file packages
* prepares an Ivy module descriptor
* uploads the packages to the specified repository
* increments the version number in the text file (if using <<_nextVersionNumberAutoIncrementFile>>)

You may notice a task called +publishIvyPublicationToIvyRepository+ or similar. This exists because the +intrepid+ plugin uses the +ivy-publish+ plugin.

[[_relative_paths]]
== Relative paths

Both +sourceDependencies+ and +packedDependencies+ support project-relative paths and workspace-relative paths. This
means that you can nest projects inside each other and put projects completely outside the workspace root, on a
relative path. For example, in the example below the root Gradle project is called 'Root' and it is able to pull in
source and/or packed dependencies to form the following directory hierarchy. The contents of the square brackets shows
the dependencies from one module to others. If the dependency starts with a slash then it's relative to the Root
workspace, otherwise it's relative to the module which is defining the dependency.

....
C:
+---Projects
    +---PJ42
        +---Root                    source  [MyApp, MyLib]
        |   +---Boost               packed
        |   +---MyLib               source  [../../Stuff/UtilityLib, SubLib, /Boost]
        |   |   +---SubLib          source  [/Boost]
        |   +---MyApp               source  [../../Stuff/Framework, ../MyLib]
        +---Stuff
            +---Framework           packed  [../UtilityLib, ../RenderingLib]
            +---UtilityLib          packed  [../RenderingLib]
            +---RenderingLib        packed
....

Transitive dependencies of +packedDependencies+ will appear next to those dependencies.  In the above example, none of
the source projects directly depends on +RenderingLib+.  However, it will still be unpacked and appear in the +Stuff+
folder, next to +UtilityLib+, because +UtilityLib+ depends on +RenderingLib+.

WARNING: Previous versions of the gloss:holygradle[] allowed published packed dependencies to specify that their
transitive dependencies should appear at some other relative location.  This feature is deprecated and will be removed
in future.  See <<useRelativePathFromIvyXml>>.

=== Ivy files

WARNING: This feature is deprecated and will be removed in future.  See <<useRelativePathFromIvyXml>>.

Whenever you publish a module which specifies source dependencies or packed dependencies the Ivy XML will have the
relative path baked in. So, for example, if you published +MyLib+ you could examine the XML and notice the relative
path +../../Stuff/+ specified for the +UtilityLib+ dependency, and if you published +SubLib+ you would see the relative
path +../+ for the +Boost+ dependency.

Relative paths chain together as you would expect. For example +Root+ depends on +MyLib+, which
depends on +SubLib+ and all the relative paths are empty. This means that the directories are
nested. After +MyLib+ and +SubLib+ are published and subsequently fetched on someone's machine, the
directory structure is still nested, even when these modules are unpacked to the central cache. This
approach does mean that it would be rather difficult to allow versions of transitive dependencies to
be overridden.  Therefore overriding transitive dependencies using +resolutionStrategy.force+ isn't
currently supported -- it may work, if your relative paths don't result in nesting, but it's not
guaranteed.
