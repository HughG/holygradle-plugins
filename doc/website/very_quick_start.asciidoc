include::stdattr.ascinc[]

= I just want to ...

include::sitemap.ascinc[]

== ... make it work!

If you are seeing error messages from gloss:gradle[] or having other problems, please see the
link:troubleshooting.html[] page.  If you can't find the solution there, see the link:support.html[]
page for where to get more help.

== ... get something from Artifactory

To get something from gloss:artifactory[] you need to know the gloss:module[] version ID (group,
name, and version), and the gloss:repository[] to get it from.  The group which publishes the module
can tell you this information, or give you a URL which links directly to it.  You also need to make
sure you have permissions in Artifactory which allow you to download it -- ask your local
administrators (see the link:support.html[] page) and/or the group lead.

=== -- just one file

It is possible to download individual ZIP files and other files directly from the Artifactory web
UI.  Log in, then click on the "Artifacts" tab, and use the "Tree Browser" or "Simple Browser" to
find the files you need.  The file structure is +/_repository_/_group_/_module_/_version_/_files_+.
For more details, see http://www.jfrog.com/confluence/display/RTF/Browsing+Artifactory.

TIP: The "Tree Browser" only shows you files that have been published at your site, or already
downloaded from another site.  If you need a file from another site but it has not been downloaded
yet, you should use the "Simple Browser", and look in the appropriate virtual repository.  If you
are not sure which repository to look in, please contact the team which published it, and/or your
local link:support.html[] contacts.

[[get_a_whole_software_module]]
=== -- a whole software module

In most cases, if you need one file from a module in gloss:artifactory[], you will also need other
files from that module and from its gloss:dependencies[].  A tool like the gloss:holygradle[] makes
this much easier.  In this case you need to do the following things.

* Find out the name of a _virtual_ gloss:repository[] which you can use to access the module.
* Find out the module version ID _and_ the gloss:configuration[](s) you need -- ask the group which
publishes the module if you are not sure.
* Make sure you have link:first_steps.html[set up your machine] for gloss:gradle[], and create a
minimal project (see link:first_steps.html#running_the_holy_gradle[]) if you don't have one already.
* Add at least one gloss:configuration[] to your +build.gradle+, if you don't have any already.
+
[source,groovy]
----
configurations {
    privateBuild
}
----
* Add a reference to the repository, if it is not already in your +build.gradle+.  (For more
information on authentication, see the link:plugin-my-credentials.html[] page.)
+
[source,groovy]
----
repositories.ivy {
    credentials {
        username my.username("Artifactory")
        password my.password("Artifactory")
    }    
    url "https://artifact-server.example-corp.com/libs-release/"
}
----
+
The credentials block is required if your server needs you to log in to access the module you need.
See link:plugin-my-credentials.html[] for details.

* Add a reference to the module in your +build.gradle+, with a mapping from your project's
configurations to the other project's configurations.
+
[source,groovy]
----
packedDependencies {
    "somelib" {
        dependency "com.example-corp.teamA:somelib:1.3.2"
        configuration "privateBuild->compileVc10Debug,compileVc10Release"
        configuration "privateBuild->debuggingVc10Debug,debuggingVc10Release"
    }
}
----
+
See link:plugin-intrepid.html#packedDependencies[] for details.

* Run +gw fAD+ in a Windows Command Prompt in your project's directory.  If you have any problems,
contact your local link:support.html[] staff or the group which publishes the module.
TIP: Before publishing your module, you should review the list of configurations in your
+build.gradle+, and the configuration mapping for each dependency.  If you do not, it may be more
difficult for other teams to use your module.  See the <<make_a_release>> section below, and the
page on link:workflows.html[] for more information.

[[start_a_new_project]]
== ... start a new project

Follow the instructions above to get "<<get_a_whole_software_module>>", and you will have a minimal
project with one packed dependency.  You can then add the other dependencies needed for your project,
fetch them all, and build it.

For more information, see the link:workflows.html#_initial_set_up[] workflow section.

== ... build an existing project

To build a project from source when it already exists, you need to do the following things.

* Make sure your machine is link:first_steps.html[set up for Gradle].
* Make sure you have permissions to access the source code repository _and_ the gloss:artifactory[]
gloss:repositories[] which contain the project's dependencies.  The team which owns the project
should have this information.
* Check out the source code using the appropriate tool--usually gloss:subversion[] or
gloss:mercurial[].
* Open a Command Prompt in the project's folder, and follow the link:workflows.html#_typical_workflow[].

Note that, if this is the first time you have accessed the project's Artifactory repository/-ies,
the Holy Gradle will pop up a dialog to prompt you for the username and password.  If the project
has gloss:source-dependencies[] you may be prompted separately for those.  It stores them in the
gloss:credential-manager[] so you will not need to supply them again until you change your password.
When your password changes, see link:plugin-my-credentials.html#updating-credentials[] for how to
update the password stored by the Holy Gradle.

[[make_a_release]]
== ... make a release of my project

Making a release can be a complex process, so this section will only give a high-level view, with
links to other sections.  It only talks about how to package up files and store them for you and
other teams to use.  It assumes that your project is already using the gloss:holygradle[] and you
are able to get all the project's dependencies and build it.  If not, please see previous sections
such as "<<start_a_new_project>>".

The main things to consider are

* what needs to be released;
* how you identify it later;
* where the released things will be stored;
* who should do the release;
* how your customers will get the release.

=== What to release

You need to consider which files to release as part of your module(s), and also whether any of your
dependencies need to be released.  (If a dependency is already in gloss:artifactory[], you do not
need to publish it again, but you may need to copy or move it between gloss:repositories[] so that
your customers can access it.)

The gloss:holygradle[] can ZIP up any files you choose from your build output and your source.  It
automatically creates an +ivy.xml+ file connecting the ZIP files to gloss:configuration[]s of your
module, so that other teams can fetch only the parts they want.  The +ivy.xml+ also has the versions
of all your dependencies, so other teams can fetch those as well.

To tell Gradle what you want published, add an entry to the +packageArtifacts+ block for some or all
of your configurations.  Suppose you have the following in your +build.gradle+ already.

[source, groovy]
----
configurations {
    privateBuild
    runtimeX64Release
    runtimeX64Debug
    // ... and other configurations
}
----

Then you could add a section like this.

[source, groovy]
----
packageArtifacts {
    // Nothing published for "privateBuild" because it is for tools
    // which are only needed to build the module, and not needed when using it.
    runtimeX64Release {
        include "Output/x64/Release/mylib_64.dll"
        include "Output/x64/Release/mylib_support_64.dll"
    }
    runtimeX64Debug {
        include "Output/x64/Debug/mylib_64_d.dll"
        include "Output/x64/Debug/mylib_support_64_d.dll"
    }
    // ... and other configurations
}
----

You can build and publish multiple projects together using the +sourceDependencies+ block:
publishing a project will also publish all of its source dependencies.

==== Publishing dependencies

You must also consider whether any of your dependencies must be published.  It is common during
development within an organisation that one team will use pre-release or "release candidate"
versions of modules from other teams.  It is also possible, when using the Holy Gradle, that you
will package up some third-party library or build tool to use in your project.  If you publish your
project in some gloss:repository[] which your customers can access, but some of your dependencies
are in other repositories which are not accessible to them, then they may not be able to fetch and
use your module.

TODO: Link to workflows, +checkPackedDependencies+, other details pages, DSL doc.

==== License restrictions

If some of your dependencies are licensed commercial software, you may not have the right to
redistribute them, or to export them to other countries.  If your customers have their own license
to get the software, you can give them a copy of the +build.gradle+ which you used to publish the
module, and they can publish it into their own private repository.  Every module published using the
gloss:holygradle[] has a +buildScript+ ZIP file which contains the script.

TODO: Link to what to do with license-restricted third-party libraries.

==== Release systems outside Artifactory

You may have other things which are not part of your project but are part of your release process --
for example, a release notes document.  You can either store them outside of gloss:artifactory[] and
keep a note of the matching ID(s) of your release (see below), or you can copy them into your
project before making the release, and publish them to Artifactory.  The Holy Gradle already does
this for source code: it doesn't include all the source but it creates a +build_info+ folder in each
ZIP file, and that has files describing the source repository and version it was published from.

=== Identifying the release

Your project has a _gloss:module[] version ID_ when you are running gloss:gradle[] and when you
publish to gloss:artifactory[].  This has three parts: _group_, _name_, and _version_.  You and
other teams can use this ID to get your module from gloss:artifactory[] later.

The name is always the name of the folder containing the +build.gradle+.  So, when you publish, you
must make sure that you have checked out the source code to a folder of the right name.

The group and version are controlled by a +publishPackages+ block.  There are several options for
setting the version number, because often you will want to control it as part of an automated build.

[source, groovy]
----
publishPackages {
    group "com.example-corp.teamA"
    nextVersionNumberEnvironmentVariable "MYLIB_VERSION_NUMBER"
}
----

=== Where to put the release

To publish to gloss:artifactory[] you must choose a local gloss:repository[] to store your release.
When choosing, you should consider

* who needs to be able to get your release;
* who should _not_ be able to get it -- for example, if it is a beta, or confidential; and
* how long it should be kept for.

The repo to use depends on the policies for your server -- see the link:support.html[] page to find
out who to ask, and tell them your choices for the points above.  A common approach is _promotion_:
your automated build publishes to a repo which keeps temporary builds, only for your team; when you
are ready to release, you copy (promote) a build to a repo where others can get it.

TODO: link to promotion, cleanup

Once you know the URL, you add it to the +publishPackages+ block.  If your server needs a username
and password to publish, you should use the +my-credentials+ plugin to get them from the
gloss:credential-manager[].

[source, groovy]
----
publishPackages {
    group "com.example-corp.teamA"
    nextVersionNumberEnvironmentVariable "MYLIB_VERSION_NUMBER"
    repositories.ivy {
        credentials {
            username my.username("Artifactory")
	    password my.password("Artifactory")
	}
	url "https://artifactory.example-corp.com/artifactory/teamA-integration-local/"
    }
}
----

WARNING: Regarding restricting access to modules, note that someone who has access may get a module
from you and pass it on to someone else who should not have access.  Artifactory can only provide a
basic level of control, to prevent accidental sharing.  You must make sure your customers understand
any restrictions, and that they also tell new members of their teams.

=== Who should do the release

The first point here is that the user who runs gloss:gradle[] must have "Deploy" permission for the
relevant gloss:repository[] in gloss:artifactory[].  Contact your team lead and/or your local
link:support.html[] contact about this.

The other important issue is if you have dependencies which also need to be released, and they were
published by another team -- who should release (promote) those modules?  If you can fetch the
dependencies, then it is _possible_ for you to promote them, but you should check the release
policies in your organisation, and usually contact the team to discuss it.

=== How customers get the release

==== Through Artifactory

To publish to gloss:artifactory[], just run +gw publish+.  If you customers have access to an
gloss:artifactory[] server, then they can fetch your module into their project with the
gloss:holygradle[], using the +packedDependencies+ block as usual.  You must tell them

* your module's version ID (+_group_/_name_/_version+); and
* the _virtual_ gloss:repository[] which they should fetch it from.

If that repository is not already in the +repositories+ section of their +build.gradle+, they must
add it directly to that file, or ask their server administrator to add it to one of the virtual
repositories which is already used in their build script.

If the team is using a different Artifactory server -- for example, at a different site -- then the
server administrator can set up a _remote_ repository on that server to cache files from a virtual
repository on your server.  Ideally, the server admin will use a name which matches your virtual
repository name (or create a virtual repository which matches it and includes the remote repo).  If
not, that admin must tell the other team which repository name to use.  (The other team could access
your server directly but that may be slower and use a lot of network capacity.)

==== Without Artifactory

The gloss:holygradle[] has a feature to let teams which use gloss:artifactory[] easily release to
teams which do not.  It downloads your module and all dependencies, plus a copy of the Holy Gradle,
into a +local_artifacts+ folder for you to distribute -- for example, as a ZIP file.  When your
customers get a copy of these files, they can run +gw fAD+ as normal, and everything will be
unpacked from the +local_artifacts+ folder into the correct location.

First, add a new configuration and a new entry to your +packageArtifacts+ section, as follows.

[source, groovy]
----
configurations {
    preBuiltArtifacts
}

// ...

packageArtifacts {
    preBuiltArtifacts {        
        include "gw.bat", "gradle/**", "gradle.properties"
        includeBuildScript {
            addPackedDependency "${project.group}:${project.name}:${project.name}"
	}
    }
}
----

Now publish your module to Artifactory as normal.  You will see a ZIP file with a name containing
the string "+preBuiltArtifacts+".  Download and unzip it to a new folder, which must *not* have the
same name as your module.  Then run

----
gw collectDependencies
----

This will download your module and all its dependencies into a folder called +local_artifacts+.
Then ZIP up the following folder and files.

* +local_artifacts/+
* +gradle/+
* +gw.bat+
* +settings.gradle+
* +build.gradle+
* +gradle.properties+

Send this file to your customer.  They can unzip it and run +gw fAD+ to unpack your module and all
its dependencies.  (You can and should test this for yourself before you send it.)

TODO: Can we just do "fetchAllSourceDependencies", without also fetching packed deps?  Or only
fFLSD?

TODO: Link to some example of the "zip external release" code (or just add it to holygradle).
