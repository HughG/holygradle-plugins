import org.gradle.api.initialization.dsl.ScriptHandler

apply plugin: 'groovy'

buildscript { ScriptHandler script ->
    // Make sure we don't publish something which is based on conflicting versions of dependencies.
    script.configurations["classpath"].resolutionStrategy { ResolutionStrategy rs ->  rs.failOnVersionConflict() }
}

subprojects {
    if (project.name.endsWith("plugin")) {
        apply plugin: "groovy"

        // Specify common dependencies for all projects.
        dependencies {
            groovy localGroovy()
            compile gradleApi()
            testCompile files("../buildSrc/build/classes/main/")
        }
    }
}

// The custom-gradle project also needs the groovy plugin, even though it's not a "-plugin" itself.
project(":custom-gradle") {
    apply plugin: "groovy"
}

subprojects {
    // Add a default configuration for any subprojects which don't have one.
    if (configurations.findByName("default") == null) {
        configurations {
            it."default"
        }
    }

    // Set a common group.
    group = "holygradle"
    
    // Set common repo info for dependencies.
    repositories {
        ivy {
            url artifactoryServer + artifactoryPluginRepo
            // We use credentials here because artifactoryPluginRepo may not be readable to anonymous users, depending
            // on local Artifactory configuration.
            credentials {
                username artifactoryUsername
                password artifactoryPassword
            }
        }
        maven {
            url artifactoryServer + 'remote-repos/'
            // We need credentials here because "remote-repos/" is a read-through cache of external repos, set up on
            // Artifactory.  If you update dependencies to require a new version of something (such as svnkit) which
            // exists in a real remote repo (such as <http://repo1.maven.org/maven2/>), but isn't cached in the local
            // Artifactory server, it will be written to the local Artifactory server.  Depending on the setup of your
            // server, that may require credentials.
            credentials {
                username artifactoryUsername
                password artifactoryPassword
            }
        }
    }
    
    // Don't cache SNAPSHOT dependencies for any length of time.
    // TODO 2013-16-18 HughG: Really, we shouldn't use any SNAPSHOT dependencies.
    configurations.all {
        resolutionStrategy.cacheChangingModulesFor 1, 'seconds'
    }
}

/*
 * PUBLISH_LOCAL_TARGET_URI is needed by both test.gradle and publish.gradle, so it's defined here,
 * keeping other related URIs with it for ease of understanding.
 */
project.ext.PUBLISH_TARGET_URI = artifactoryServer + artifactoryPluginPublishRepo + "/"
project.ext.PUBLISH_LOCAL_TARGET_URI = new File(project.projectDir as File, "local_repo").toURI().toString() + "/"
/**
 * LOCAL_GRADLE_USER_HOME is passed to integration tests for the Gradle daemon (launched by the WrapperBuildLauncher in
 * AbstractHolyGradleIntegrationTest) to use as its Gradle user home.  Note that the plugins to test aren't "downloaded"
 * to here from the PUBLISH_LOCAL_TARGET_URI folder: Gradle seems to be smart enough to just use them in place.
 */
project.ext.LOCAL_GRADLE_USER_HOME = new File(project.projectDir as File, "local_gradle_user_home").toString()

/**
 * CUSTOM_GRADLE_BASE_NAME is needed by the custom-gradle project, but also by the integration test setup.
 */
project.ext.CUSTOM_GRADLE_BASE_NAME = "custom-gradle-${gradle.gradleVersion}"

apply from: "versionInfo.gradle"
apply from: "publish.gradle"
apply from: "test.gradle"
apply from: "website.gradle"
