import holygradle.util.Helper
import org.gradle.api.internal.artifacts.dependencies.DefaultExternalModuleDependency

subprojects {
    if (project.name.endsWith("plugin")) {
        apply plugin: "groovy"

        test {
            systemProperties([
                'holygradle.gradleHomeDir': project.gradle.gradleHomeDir.path,
                'holygradle.gradleUserHomeDir': project.gradle.gradleUserHomeDir.path
            ])
        }

        dependencies {
            groovy localGroovy()
            compile gradleApi()
            testCompile files("../buildSrc/build/classes/main/")
        }
    }
}
project("custom-gradle") {
    apply plugin: "groovy"
}

/**
 * This task puts the Hg master repo URL and working directory version/branch/tags into a property and text file, which
 * feed into the packaging tasks for all sub-projects, so all build outputs are stamped with info on where they came
 * from.
 *
 *   - JAR files put it in META-INF/MANIFEST/MF.
 *   - custom-gradle puts it in the init.d/holy-gradle-init.gradle.
 *   - credential-store puts it in the Windows file properties of the generated EXE.
 *
 * If you change the form or location of this info, please update not only this comment but also the wiki page at
 * https://bitbucket.org/nm2501/holy-gradle-plugins/wiki/Home.
 */
task setHgVersionInfo {
    new ByteArrayOutputStream().withStream { os ->
        String hgInfoString = "unknown"
        exec {
            executable = "hg"
            args = ["paths", "default"]
            standardOutput = os
        }
        (new PrintStream(os)).withStream { it.print(" ") }
        exec {
            executable = "hg"
            args = ["id", "-ibt"]
            standardOutput = os
        }

        // Store both command outputs in one string with no line breaks.
        project.ext.hgVersionInfo = os.toString().replaceAll("[\\r\\n]", "")

        // Write the version to a file, so that the file can be seen as changed (or not) by other tasks, to force them
        // to re-run.
        project.ext.hgVersionInfoFile = new File('hgVersionInfo.txt')
        project.hgVersionInfoFile.text = project.hgVersionInfo
    }
}

setHgVersionInfo.outputs.upToDateWhen { false }

subprojects { 
    project.gradle.taskGraph.whenReady {
        if (project.gradle.taskGraph.hasTask(publishRelease)) {
            println "You will now be asked for a publishing version for each sub-project,"
            println "before any of them are built and published."
        }
    }
}

subprojects {
    if (configurations.findByName("default") == null) {
        configurations {
            it."default"
        }
    }

    group = "holygradle"
    
    repositories {
        ivy {
            url artifactoryServer + artifactoryPluginRepo
        }
        maven {
            url artifactoryServer + 'remote-repos/'
            // We need credentials here because "remote-repos/" is a read-through cache of external repos, set up on
            // Artifactory.  If you update dependencies to require a new version of soemthing (such as svnkit) which
            // exists in a real remote repo (such as <http://repo1.maven.org/maven2/>), but isn't cached in the local
            // Artifactory server, it will be written to the local Artifactory server.  Depending on the setup of your
            // server, that may require credentials.
            credentials {
                username artifactoryUsername
                password artifactoryPassword
            }
        }
    }
    
    configurations.all {
        resolutionStrategy.cacheChangingModulesFor 1, 'seconds'
    }

    if (project.path == ":custom-gradle") {
        project.afterEvaluate {
            project.createVersionedInitScript.dependsOn setHgVersionInfo
        }
    } else if (project.path == ":credential-store") {
        project.afterEvaluate {
            project.createProjectVersionFile.dependsOn setHgVersionInfo
        }
    } else if (project.plugins.hasPlugin("groovy")) {
        // We don't need an "afterEvaluate" here because "jar" is a standard task for "groovy" projects.
        project.jar {
            dependsOn setHgVersionInfo
            manifest {
                attributes(["Implementation-Version": rootProject.hgVersionInfo])
            }
        }
    }

    ["publishRelease", "publishSnapshot"].each { taskName ->
        project.task(taskName, type: Upload) {
            configuration = configurations.default
            group = "Publishing"
            uploadDescriptor = true
            descriptorDestination = new File("ivy.xml")
            
            repositories.ivy {
                credentials {
                    username artifactoryUsername
                    password artifactoryPassword
                }
                url artifactoryServer + artifactoryPluginPublishRepo + "/"
            }
            
            doLast {
                println "Published ${project.version} at: " + new Date()
            }
        }
    }
    
    project.gradle.taskGraph.whenReady {
        // Only publish to one repository at a time.
        int publishCount = 0
        if (project.gradle.taskGraph.hasTask(publishSnapshot)) {
            publishCount++
        }
        if (project.gradle.taskGraph.hasTask(publishRelease)) {
            publishCount++
        }
        if (publishCount > 1) {
            throw new RuntimeException("Only publish release or snapshot, but not both at the same time because the version number is different.")
        }
        
        // Configure the version number according to which repository we're publishing to.
        //
        // NOTE 2013-06-06 HughG: This has to be done now, rather than in a "doFirst" block,
        // otherwise the project version will be changed after Gradle has decided on the filename
        // for the JAR file, and we'll end up publishing the ivy.xml but no JAR.
        if (project.gradle.taskGraph.hasTask(publishSnapshot)) {
            def username = System.getProperty("user.name").toLowerCase()
            project.version = "${username}-SNAPSHOT"
        }
        if (project.gradle.taskGraph.hasTask(publishRelease)) {
            Helper.chooseNextVersionNumberWithUserInput(project)

            println()
            println "Publishing '${project.group}:${project.name}:${project.version}'..."
            println()
        }
    }

    if (project.tasks.findByPath("test") != null) {
        task testReport(type: DefaultTask) {
            dependsOn test
            group = "Verification"
            description "Opens the test report and runs the tests."
            doFirst {
                project.exec {
                    commandLine "cmd", "/c", "start", "${testReportDir}/index.html"
                }
            }
        }
    
        // publishSnapshot.dependsOn test
        publishRelease.dependsOn test
    }
}