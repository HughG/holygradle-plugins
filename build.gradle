import org.gradle.api.initialization.dsl.ScriptHandler

apply plugin: 'groovy'

// Force-add a Mercurial client-side hook to avoid comitting anything with "banned" words.
project.ext.HGRC = new File('.hg/hgrc')
def ensureHgHook(String hookName, String hookText) {
    if (!HGRC.readLines().any { it.contains(hookName) }) {
        HGRC.withWriterAppend { BufferedWriter bw ->
            bw.withPrintWriter { PrintWriter pw ->
                pw.println()
                pw.println('[hooks]')
                pw.println(hookName + ' = ' + hookText)
            }
        }
    }
}
String findBannedWords = 'findstr /i /r /g:local\\holy-gradle-plugins\\banned-words.txt & ' +
    'if errorlevel 1 (exit /b 0) else (exit /b 1)'
ensureHgHook(
    'pretxncommit.sanitise',
    'hg export tip | ' + findBannedWords
)

// Force-copy build bootstrap files to independenct sub-projects, so they stay up to date.
["https-setup-kit", "wrapper-starter-kit", "wrapper-starter-kit/newWrapper"].each {
    File otherProjectDir = new File(projectDir, it)
    ["gw.bat", "gradle/base-url-lookup.txt", "gradle/certs/**"].each { String copyPattern ->
        copy {
            into(otherProjectDir)
            from(projectDir) {
                include copyPattern
            }
        }
    }
}

buildscript { ScriptHandler script ->
    // Make sure we don't publish something which is based on conflicting versions of dependencies.
    script.configurations["classpath"].resolutionStrategy { ResolutionStrategy rs ->  rs.failOnVersionConflict() }
}

subprojects {
    if (project.name.endsWith("plugin") || project.name == "integration") {
        apply plugin: "groovy"

        // Specify common dependencies for all projects.
        dependencies {
            compile localGroovy()
            compile gradleApi()
            testCompile files("../buildSrc/build/classes/main/")
        }
    }
}

// The custom-gradle project also needs the groovy plugin, even though it's not a "-plugin" itself.
project(":custom-gradle") {
    apply plugin: "groovy"
}

subprojects {
    // Add a default configuration for any subprojects which don't have one.
    if (configurations.findByName("default") == null) {
        configurations {
            it."default"
        }
    }

    // Set a common group.
    group = "holygradle"
    
    // Set common repo info for dependencies.
    repositories {
        ivy {
            url artifactoryServer + artifactoryPluginRepo
            // We use credentials here because artifactoryPluginRepo may not be readable to anonymous users, depending
            // on local Artifactory configuration; or they may not be able to deploy into caches.
            credentials {
                username artifactoryUsername
                password artifactoryPassword
            }
        }
        maven {
            url artifactoryServer + 'remote-repos/'
            // We need credentials here because "remote-repos/" is a read-through cache of external repos, set up on
            // Artifactory.  If you update dependencies to require a new version of something (say, http-builder) which
            // exists in a real remote repo (such as <http://repo1.maven.org/maven2/>), but isn't cached in the local
            // Artifactory server, it will be written to the local Artifactory server.  Depending on the setup of your
            // server, that may require credentials.
            credentials {
                username artifactoryUsername
                password artifactoryPassword
            }
        }
    }
    
    // Don't cache SNAPSHOT dependencies for any length of time.
    // TODO 2013-16-18 HughG: Really, we shouldn't use any SNAPSHOT dependencies.
    configurations.all {
        resolutionStrategy.cacheChangingModulesFor 1, 'seconds'
    }
}

/*
 * PUBLISH_LOCAL_TARGET_URI is needed by both test.gradle and publish.gradle, so it's defined here,
 * keeping other related URIs with it for ease of understanding.
 */
project.ext.PUBLISH_RELEASE_TARGET_URI = artifactoryServer + artifactoryPluginReleasePublishRepo + "/"
project.ext.PUBLISH_SNAPSHOT_TARGET_URI = artifactoryServer + artifactoryPluginSnapshotPublishRepo + "/"
project.ext.PUBLISH_LOCAL_TARGET_URI = new File(project.projectDir as File, "local_repo").toURI().toString() + "/"
/*
 * LOCAL_GRADLE_USER_HOME is passed to integration tests for the Gradle daemon (launched by the WrapperBuildLauncher in
 * AbstractHolyGradleIntegrationTest) to use as its Gradle user home.  Note that the plugins to test aren't "downloaded"
 * to here from the PUBLISH_LOCAL_TARGET_URI folder: Gradle seems to be smart enough to just use them in place.
 */
project.ext.LOCAL_GRADLE_USER_HOME = new File(project.projectDir as File, "local_gradle_user_home").toString()

/*
 * CUSTOM_GRADLE_BASE_NAME is needed by the custom-gradle project, but also by the integration test setup.
 */
project.ext.CUSTOM_GRADLE_BASE_NAME = "custom-gradle-${gradle.gradleVersion}"

apply from: "versionInfo.gradle"
apply from: "publish.gradle"
apply from: "test.gradle"
apply from: "website.gradle"
