buildscript {
    ext.kotlin_version = '1.2.31'

    repositories {
        mavenCentral()
    }
    it.dependencies {
        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
    }
}

def javaVersion = System.getProperty('java.specification.version').split('\\.')*.toInteger()
if (!(javaVersion[0] >= 1 || javaVersion[1] >= 8)) {
    throw new RuntimeException(
        "The Holy Gradle can only be built with JDK 1.8 or later.  If you need to set JAVA_HOME to a different version, " +
        "please set HOLY_GRADLE_JAVA_HOME to a 1.8 or later JDK."
    )
    /*
        If you try to build with JDK 7 or earlier, you'll get the following error,
        because the Kotlin plugin needs JDK 1.8 or later.

        > Failed to apply plugin [id 'kotlin']
           > Could not generate a proxy class for class org.jetbrains.kotlin.gradle.tasks.KotlinCompile.
   */
}

apply plugin: 'groovy'

// Force-add a Mercurial client-side hook to avoid committing anything with "banned" words.
project.ext.HGRC = new File(projectDir, '.hg/hgrc')
def ensureHgHook(String hookName, String hookText) {
    if (!HGRC.readLines().any { it.contains(hookName) }) {
        HGRC.withWriterAppend { BufferedWriter bw ->
            bw.withPrintWriter { PrintWriter pw ->
                pw.println()
                pw.println('[hooks]')
                pw.println(hookName + ' = ' + hookText)
            }
        }
    }
}
String findBannedWords = 'findstr /i /r /g:local\\holy-gradle-plugins\\banned-words.txt & ' +
    'if errorlevel 1 (exit /b 0) else (exit /b 1)'
ensureHgHook(
    'pretxncommit.sanitise',
    'hg export tip | ' + findBannedWords
)

// Force-copy GENERAL build bootstrap files to independent sub-projects, so they stay up to date.
//
// We don't copy these into "wrapper-starter-kit/newWrapper" because the "wrapper" task itself will write
// then into that folder when it runs.
["https-setup-kit", "wrapper-starter-kit"].each {
    File otherProjectDir = new File(projectDir, it)
    copy {
        into(otherProjectDir)
        from(projectDir) {
            include "gradlew.bat"
            include "gw.bat"
        }
    }
    copy {
        into("${otherProjectDir}/gradle")
        from("${projectDir}/custom-gradle-core-plugin/src") {
            include "init.d/**"
        }
    }
}

// Force-copy LOCAL build bootstrap files to independent sub-projects, so they stay up to date.
//
// If you modify this, you probably also need to modify the copy step added to createWrapper in
// "wrapper-starter-kit/newWrapper/build.gradle".  These files aren't written in by the "wrapper"
// task because they're not packed into the plugin, because they're site-local and private.
["https-setup-kit", "wrapper-starter-kit"].each {
    File otherProjectDir = new File(projectDir, it)
    ["gradle/base-url-lookup.txt", "gradle/proxy-lookup.txt", "gradle/certs/**"].each { String copyPattern ->
        copy {
            into(otherProjectDir)
            from(projectDir) {
                include copyPattern
            }
        }
    }
}

subprojects {
    // Add a default configuration for any subprojects which don't have one.
    configurations.maybeCreate("default")

    // Set a common group.
    group = "holygradle"

    // Set common repo info for dependencies.
    repositories {
        if (project.hasProperty('artifactoryServer')) {
            ivy {
                url artifactoryServer + artifactoryPluginRepo
                // We use credentials here because artifactoryPluginRepo may not be readable to anonymous users,
                // depending on local Artifactory configuration; or they may not be able to deploy into caches.
                credentials {
                    username artifactoryUsername
                    password artifactoryPassword
                }
            }
            maven {
                url artifactoryServer + 'remote-repos/'
                // We need credentials here because "remote-repos/" is a read-through cache of external repos, set up on
                // Artifactory.  If you update dependencies to require a new version of something (say, http-builder)
                // which exists in a real remote repo (such as <http://repo1.maven.org/maven2/>), but isn't cached in
                // the local Artifactory server, it will be written to the local Artifactory server.  Depending on the
                // setup of your server, that may require credentials.
                credentials {
                    username artifactoryUsername
                    password artifactoryPassword
                }
            }
        } else {
            mavenCentral()
            maven { url 'https://repo.gradle.org/gradle/plugins-releases' }
        }
    }
}

subprojects {
    if (project.name.endsWith("plugin")
            || project.name == "integration"
            || project.name == "holygradle-kotlin-dsl"
    ) {
        apply plugin: "groovy"
        apply plugin: 'kotlin'
        sourceCompatibility = 1.8

        configurations {
            optional
        }

        // Specify common dependencies for all projects.
        dependencies {
            compile localGroovy()
            compile gradleApi()
            compile "org.jetbrains.kotlin:kotlin-stdlib-jre8:$kotlin_version"
            compile "org.jetbrains.kotlin:kotlin-reflect:$kotlin_version"
            compile "org.jetbrains.kotlin:kotlin-compiler-embeddable:$kotlin_version"

            testCompile files("../buildSrc/build/classes/main/")
            testCompile group: 'junit', name: 'junit', version: '4.12'
            testCompile group: 'org.mockito', name: 'mockito-core', version: '1.10.19'
        }

        compileKotlin {
            kotlinOptions {
                languageVersion = "1.2"
            }
        }
    }
    if (project.name.endsWith("plugin")
            || project.name == "integration"
    ) {
        dependencies {
            compile project(':holygradle-kotlin-dsl')
        }
    }
}

/*
 * PUBLISH_LOCAL_TARGET_URI is needed by both test.gradle and publish.gradle, so it's defined here,
 * keeping other related URIs with it for ease of understanding.
 */
if (project.hasProperty('artifactoryServer')) {
    project.ext.PUBLISH_RELEASE_TARGET_URI = artifactoryServer + artifactoryPluginReleasePublishRepo + "/"
    project.ext.PUBLISH_SNAPSHOT_TARGET_URI = artifactoryServer + artifactoryPluginSnapshotPublishRepo + "/"
} else {
    project.ext.PUBLISH_RELEASE_TARGET_URI = 'Cannot_publish_because_property_artfactoryServer_is_not_set'
    project.ext.PUBLISH_SNAPSHOT_TARGET_URI = 'Cannot_publish_because_property_artfactoryServer_is_not_set'
}
project.ext.PUBLISH_LOCAL_TARGET_URI = new File(project.projectDir as File, "local_repo").toURI().toString() + "/"
/*
 * LOCAL_GRADLE_USER_HOME is passed to integration tests for the Gradle daemon (launched by the WrapperBuildLauncher in
 * AbstractHolyGradleIntegrationTest) to use as its Gradle user home.  Note that the plugins to test aren't "downloaded"
 * to here from the PUBLISH_LOCAL_TARGET_URI folder: Gradle seems to be smart enough to just use them in place.
 */
project.ext.LOCAL_GRADLE_USER_HOME = new File(project.projectDir as File, "local_gradle_user_home").toString()

/*
 * CUSTOM_GRADLE_BASE_NAME is needed by the custom-gradle project, but also by the integration test setup.
 */
project.ext.CUSTOM_GRADLE_BASE_NAME = "custom-gradle"

apply from: "versionInfo.gradle"
apply from: "publish.gradle"
apply from: "test.gradle"
apply from: "website.gradle"
