import java.nio.file.Files
import java.nio.file.Path

import org.gradle.process.JavaForkOptions

void maybeForward(JavaForkOptions forkOptions, String propertyName) {
    String extraArgs = System.getProperty(propertyName)
    if (extraArgs != null) {
        forkOptions.systemProperty(propertyName, extraArgs)
    }
}

void maybeForwardHttpProxyProperties(JavaForkOptions forkOptions) {
    maybeForward(forkOptions, "http.proxyHost")
    maybeForward(forkOptions, "http.proxyPort")
}

void maybeForwardExtraArguments(JavaForkOptions forkOptions) {
    maybeForward(forkOptions, "holygradle.extraArgsForIntegrationTest")
}


task cleanIntegrationTestState (type: Delete) { Delete t ->
    // We delete any previously-downloaded custom-gradle distribution, to ensure we're testing the latest
    // build.  We _have to_ do this explicitly because (a) Gradle doesn't automatically update snapshot versions of
    // wrapper distributions; and (b) even if we're building a non-snapshot version, it might be the same as some
    // version we previously downloaded from the local_repo, if we were trying to publish a release build but it failed.
    //
    // Note that, because of Gradle defect http://issues.gradle.org/browse/GRADLE-2756, distributions used by the
    // tooling API (as used by the integration tests) are always unpacked in the default Gradle user home directory,
    // even if the user has configured it to be elsewhere.
    t.doFirst {
        // We have to set this up in a doFirst block, because the project version isn't set at task creation time,
        // but is by task execution, as long as one of the "publish locally" tasks is in the task graph.
        if (!project.getIsPublishing()) {
            throw new RuntimeException("${t.name} can only be used with a publish task, which will set the version")
        }

        final File wrapperDir = new File(StartParameter.DEFAULT_GRADLE_USER_HOME, "wrapper")
        final File distsDir = new File(wrapperDir, "dists")
        final String customDistBaseName = project.CUSTOM_GRADLE_BASE_NAME
        final String customDistName = "${customDistBaseName}-${project.version}"
        final File customDistDir = new File(distsDir, customDistName)
        t.delete customDistDir
    }
}

// Make the local custom-gradle publish task depend on the integration test clean-up.  The clean-up can't run by itself
// because it requires the publish task to be in the task graph, to set the version.
(project.rootProject.tasks["publishCustomGradleLocally"] as Task).dependsOn(cleanIntegrationTestState)

project.ext.setUpTests = { Project project ->
    // For any projects with a "test" task, other than the custom distribution project, add
    //   - extra test dependencies;
    //   - integration tests; and
    //   - a way to launch the test reports.
    if (project.tasks.findByPath("test") == null || project.path == ":custom-gradle") {
        return
    }

    project.dependencies { DependencyHandler deps ->
        deps.add('testCompile', 'org.hamcrest:hamcrest-library:1.3')
    }


    // Separate out unit tests and integration tests
    project.tasks.test { Test t ->
        t.description = "Run the unit tests (test classes not ending in 'IntegrationTest')."
        t.include "**/*Test.*"
        t.exclude "**/Abstract*.*"
        t.exclude "**/*IntegrationTest.*"

        if (project.name != "integration") {
            project.tasks["publishPluginsLocally"].dependsOn(t)
        }
    }
    project.task([type: Test], "integTest") { Test t ->
        t.group = "Verification"
        t.description = "Run the integration tests (test classes ending in 'IntegrationTest')."
        t.include "**/*IntegrationTest.*"
        t.exclude "**/Abstract*.*"
        t.testReportDir = file("${project.reporting.baseDir}/$name")
        // The overall "integration" project has integration tests but doesn't publish its own plugin: it tests all
        // the plugins from other projects.
        if (project.name != "integration") {
            t.dependsOn(project.findProject(":custom-gradle").tasks["publishCustomGradleLocally"])
            t.dependsOn(project.tasks["publishPluginsLocally"])

            Task overallIntegTest = project.findProject(":integration").tasks["integTest"]
            // Make sure we run the overall integration tests only after each plugins have been
            // integration-tested.
            overallIntegTest.dependsOn t
            // Make sure we publish this plugin only after all plugins have been integration-tested
            // and the overall integration tests have been run.
            project.tasks["publishPluginsReally"].dependsOn overallIntegTest
        }

        t.doFirst {
            // Set up a number of system properties needed by the integration tests.  We have to set these up in a
            // doFirst block, because the project version isn't set at task creation time, but is by task execution.
            maybeForwardHttpProxyProperties(t)
            maybeForwardExtraArguments(t)
            final String customDistBaseName = project.findProject(":custom-gradle").CUSTOM_GRADLE_BASE_NAME
            final String customDistName = "${customDistBaseName}-${project.version}"
            final String distributionPath = "holygradle/custom-gradle/${project.version}/${customDistName}.zip"
            final String distributionURIString = URI.create(project.PUBLISH_LOCAL_TARGET_URI + distributionPath).toString()
            t.systemProperty("holygradle.pluginsRepoOverride", project.PUBLISH_LOCAL_TARGET_URI.toString())
            t.systemProperty("holygradle.distributionForIntegrationTest", distributionURIString)
            t.systemProperty("holygradle.gradleUserHomeForIntegrationTest", project.LOCAL_GRADLE_USER_HOME.toString())
            t.systemProperty("holygradle.versionForIntegrationTest", project.version)
        }
    }
    // Make the real publish tasks depend on the integration test (unless disabled)
    if (project.hasProperty('noIntegTest')) {
         if (project.version.endsWith('-SNAPSHOT')) {
            // Skip integration testing.
        } else {
            throw new RuntimeException("You can only use -PnoIntegTest for SNAPSHOT releases, but this is ${project.version}")
        }
    } else {
        project.publishReallyTasks.each { Task publishReallyTask ->
            publishReallyTask.dependsOn project.tasks["integTest"]
        }
    }

    project.task('showTestReport', type: DefaultTask) {
        group = "Verification"
        description "Opens the unit test report."
        doLast {
            project.exec {
                commandLine "cmd", "/c", "start", "${test.testReportDir}/index.html"
            }
        }
    }
    project.task('showIntegrationTestReport', type: DefaultTask) {
        group = "Verification"
        description "Opens the integration test report."
        doLast {
            project.exec {
                commandLine "cmd", "/c", "start", "${integTest.testReportDir}/index.html"
            }
        }
    }

    /*
        This method detects and removes broken directory (and file) symlinks.

        Through experimentation, I have discovered that the following APIs return values as follow
        for broken directory symlinks.  (I haven't checked what happens for broken file symlinks.)

            Files.isSymbolicLink    true
            Files.isRegularFile     false
            Files.isDirectory       false   (but returns true for non-broken directory symlinks)
            Fiies.exists            false   (again, true for non-broken directory symlinks)
            Path.toRealPath         throws IOException (java.nio.file.NoSuchFileException)
     */
    project.ext.deleteBrokenSymlinksRecursively = { File dir ->
        if (!dir.exists()) {
            project.logger.info "Skipping non-existent ${dir}"
            return
        }

        dir.eachFileRecurse(groovy.io.FileType.FILES) { File f ->
            java.nio.file.Path p = f.toPath()
            if (Files.isSymbolicLink(p) && !Files.exists(p)) {
                if (f.delete()) {
                    project.logger.info "Deleted broken symlink ${f}"
                } else {
                    project.logger.warn "Failed to delete apparently broken symlink ${f}"
                }
            }
        }
    }

    project.task('deleteTestSymlinks') {
        description = "Delete any broken symlinks in the test source folder(s), to make sure it can build."
        doFirst {
            // Broken symlinks will cause compileTestGroovy to fail (because it tries to scan the folder
            // hierarchy for source).  Broken symlinks can appear if the top-level test repo dir is
            // deleted directly.
            sourceSets.test.allSource.srcDirs.each { dir -> deleteBrokenSymlinksRecursively dir }
        }
        tasks["compileTestGroovy"].dependsOn it
    }

}

// Set up tests for integration first, so other projects can depend on its integTest.
setUpTests(findProject(':integration'))
subprojects.findAll { it.path != ':integration' }.each { println it.path; setUpTests(it) }