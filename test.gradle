import groovy.io.FileType

import java.nio.file.Files

void maybeForward(JavaForkOptions forkOptions, String propertyName) {
    String extraArgs = System.getProperty(propertyName)
    if (extraArgs != null) {
        forkOptions.systemProperty(propertyName, extraArgs)
    }
}

void maybeForwardHttpProxyProperties(JavaForkOptions forkOptions) {
    maybeForward(forkOptions, "http.proxyHost")
    maybeForward(forkOptions, "http.proxyPort")
}

void maybeForwardExtraArguments(JavaForkOptions forkOptions) {
    maybeForward(forkOptions, "holygradle.extraArgsForIntegrationTest")
}

project.ext.setUpTests = { Project project ->
    // For any projects with a "test" task, other than the custom distribution project, add
    //   - extra test dependencies;
    //   - integration tests; and
    //   - a way to launch the test reports.
    if (project.tasks.findByPath("test") == null || project.path == ":custom-gradle") {
        return
    }

    project.dependencies { DependencyHandler deps ->
        deps.add('testCompile', 'org.hamcrest:hamcrest-library:1.3')
    }


    // Separate out unit tests and integration tests
    project.tasks.test { Test t ->
        t.description = "Run the unit tests (test classes not ending in 'IntegrationTest')."
        t.include "**/*Test.*"
        t.exclude "**/Abstract*.*"
        t.exclude "**/*IntegrationTest.*"

        if (project.name != "integration") {
            project.tasks["publishPluginsLocally"].dependsOn(t)
        }
        if (project.hasProperty('noTest')) {
             if (project.version.endsWith('SNAPSHOT-0')) {
                // Skip unit testing.
                t.enabled = false
            } else {
                 if (!project.hasProperty('publishWithoutTests')) {
                     throw new RuntimeException(
                         "You can only use -PnoTest for SNAPSHOT releases, but this is ${project.version}"
                     )
                 }
            }
        }
    }
    project.task([type: Test], "integTest") { Test t ->
        t.group = "Verification"
        t.description = "Run the integration tests (test classes ending in 'IntegrationTest')."
        t.include "**/*IntegrationTest.*"
        t.exclude "**/Abstract*.*"
        t.reports.html.destination = file("${project.reporting.baseDir}/$name")
        
        // The overall "integration" project has integration tests but doesn't publish its own plugin: it tests all
        // the plugins from other projects.
        if (project.name != "integration") {
            t.dependsOn(project.tasks["publishPluginsLocally"])

            Task overallIntegTest = project.findProject(":integration").tasks["integTest"]

            if (!project.hasProperty('rootIntegTestOnly')) {
                // Make sure we run the overall integration tests only after each plugins have been
                // integration-tested.
                overallIntegTest.dependsOn t
            }

            // Make the real publish tasks depend on the integration test 
            if (!project.hasProperty('noIntegTest')) {
                // Make sure we publish this plugin only after all plugins have been integration-tested
                // and the overall integration tests have been run (unless disabled).
                project.tasks["publishPluginsReally"].dependsOn overallIntegTest
            }
        }

        t.doFirst {
            // Set up a number of system properties needed by the integration tests.  We have to set these up in a
            // doFirst block, because the project version isn't set at task creation time, but is by task execution.
            maybeForwardHttpProxyProperties(t)
            maybeForwardExtraArguments(t)
            t.systemProperty("holygradle.pluginsRepoOverride", project.PUBLISH_LOCAL_TARGET_URI.toString())
            t.systemProperty("holygradle.customInitScriptPath", project.rootProject.file('/custom-gradle-core-plugin/src/init.d/holy-gradle-init.gradle').toString())
            t.systemProperty("holygradle.gradleUserHomeForIntegrationTest", project.LOCAL_GRADLE_USER_HOME.toString())
            t.systemProperty("holygradle.versionForIntegrationTest", project.version)
        }
    }
    // Make the real publish tasks depend on the integration test (unless disabled)
    if (project.hasProperty('noIntegTest')) {
         if (project.version.endsWith('SNAPSHOT-0')) {
            // Skip integration testing.
        } else {
            if (!project.hasProperty('publishWithoutTests')) {
                throw new RuntimeException(
                    "You can only use -PnoIntegTest for SNAPSHOT releases, but this is ${project.version}"
                )
            }
        }
    } else {
        project.publishReallyTasks.each { Task publishReallyTask ->
            publishReallyTask.dependsOn project.tasks["integTest"]
        }
    }

    if (project.name != "integration") {
        project.task('showTestReport', type: DefaultTask) {
            group = "Verification"
            description "Opens the unit test report."
            File report = new File(project.test.reports.html.destination, "index.html")
            doLast {
                project.exec {
                    commandLine "cmd", "/c", "if exist ${report} start ${report}"
                }
            }
        }
    }
    project.task('showIntegrationTestReport', type: DefaultTask) {
        group = "Verification"
        description "Opens the integration test report."
        File report = new File(project.integTest.reports.html.destination, "index.html")
        doLast {
            project.exec {
                commandLine "cmd", "/c", "if exist ${report} start ${report}"
            }
        }
    }

    /*
        This method detects and removes broken directory (and file) symlinks.

        Through experimentation, I have discovered that the following APIs return values as follow
        for broken directory symlinks.  (I haven't checked what happens for broken file symlinks.)

            Files.isSymbolicLink    true
            Files.isRegularFile     false
            Files.isDirectory       false   (but returns true for non-broken directory symlinks)
            Fiies.exists            false   (again, true for non-broken directory symlinks)
            Path.toRealPath         throws IOException (java.nio.file.NoSuchFileException)
     */
    project.ext.deleteBrokenSymlinksRecursively = { File dir ->
        if (!dir.exists()) {
            project.logger.info "Skipping non-existent ${dir}"
            return
        }

        dir.eachFileRecurse(FileType.FILES) { File f ->
            java.nio.file.Path p = f.toPath()
            if (Files.isSymbolicLink(p) && !Files.exists(p)) {
                if (f.delete()) {
                    project.logger.info "Deleted broken symlink ${f}"
                } else {
                    project.logger.warn "Failed to delete apparently broken symlink ${f}"
                }
            }
        }
    }

    project.task('deleteTestSymlinks') {
        description = "Delete any broken symlinks in the test source folder(s), to make sure it can build."
        doFirst {
            // Broken symlinks will cause compileTestGroovy to fail (because it tries to scan the folder
            // hierarchy for source).  Broken symlinks can appear if the top-level test repo dir is
            // deleted directly.
            sourceSets.test.allSource.srcDirs.each { dir -> project.deleteBrokenSymlinksRecursively dir }
        }
        tasks["compileTestGroovy"].dependsOn it
    }

}

// Set up tests for integration first, so other projects can depend on its integTest.
setUpTests(findProject(':integration'))
subprojects.findAll { it.path != ':integration' }.each { setUpTests(it); }