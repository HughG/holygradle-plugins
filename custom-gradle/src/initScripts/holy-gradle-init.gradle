// NOTE: IntelliJ claims that these are unused imports but, for some reason, Gradle (1.4) needs them when this init
// script is actually run.
import org.gradle.api.artifacts.repositories.ArtifactRepository
import org.gradle.api.artifacts.repositories.IvyArtifactRepository
import org.gradle.api.artifacts.repositories.MavenArtifactRepository
import org.gradle.api.initialization.dsl.ScriptHandler

/**
 * This Java system property can optionally be supplied with a (file) URL value which will be added as the first repo
 * used by the build script to find plugins, so that integration tests can force locally-published versions of the
 * plugins to be tested.
 * 
 * This property key must match the one in holygradle.test.AbstractHolyGradleIntegrationTest, in
 * custom-gradle-core-plugin.
 */
final String PLUGINS_REPO_OVERRIDE_SYSTEM_PROPERTY_KEY = "holygradle.pluginsRepoOverride"
final String PLUGINS_REPO_OVERRIDE = System.getProperty(PLUGINS_REPO_OVERRIDE_SYSTEM_PROPERTY_KEY)

class HolyGradlePlugins {
    // NOTE 2013-06-07 HughG: Referenced by holygradle.custom_gradle.VersionInfo.
    public Map<String,String> usages = [:]

    private ScriptHandler buildscript
    private Project project
    
    HolyGradlePlugins(ScriptHandler buildscript, Project project) {
        this.buildscript = buildscript
        this.project = project
        // Point the buildscript to the Holy Gradle plugins.
        if (project.property("holyGradlePluginsRepository") != null) {
            buildscript.repositories { RepositoryHandler repoHandler ->
                repoHandler.ivy { IvyArtifactRepository repo ->
                    repo.url = project.property("holyGradlePluginsRepository")
                }
            }
        }
        // Point the buildscript to a source of dependencies for the Holy Gradle plugins.
        if (project.property("holyGradleRemoteRepository") != null) {
            buildscript.repositories { RepositoryHandler repoHandler ->
                repoHandler.maven { MavenArtifactRepository repo ->
                    repo.url = project.property("holyGradleRemoteRepository")
                }
            }
        }

        // By default, set the resolution strategy for buildscript dependencies so that those
        // specified with dynamic version numbers (e.g. "1.0.+") are cached for 1 hour.
        buildscript.configurations.all ((Closure){ Configuration conf ->
            conf.resolutionStrategy { ResolutionStrategy res ->
                res.cacheChangingModulesFor 1, 'seconds'
                res.cacheDynamicVersionsFor 1, 'hours'
            }
        })
    }

    // This is an API for use by build scripts, so ignore the "unused" warning.
    @SuppressWarnings("GroovyUnusedDeclaration")
    public void use(String plugin_version) {
        String group = "holygradle"
        String plugin
        String version
        final String error = "Invalid format for 'gplugins.use'. The parameter should be in the form '<module>:<version>'."
        if (plugin_version.contains(":")) {
            String[] split = plugin_version.split(":")
            if (split.size() == 2) {
                plugin = split[0]
                version = split[1]
            } else if (split.size() == 3) {
                group = split[0]
                plugin = split[1]
                version = split[2]
            } else {
                throw new RuntimeException(error)
            }
        } else {
            throw new RuntimeException(error)
        }
        useInternal(group, plugin, version)
    }

    // This is an API for use by build scripts, so ignore the "unused" warning.
    @SuppressWarnings("GroovyUnusedDeclaration")
    public void use(String plugin, String version) {
        useInternal "holygradle", plugin, version
    }
    
    private void useInternal(String group, String plugin, String version) {
        // This allows plugins to be specified as "foo" or "foo-plugin".
        String pluginFullName = null
        if (plugin.endsWith("-plugin")) {
            pluginFullName = plugin
            plugin = plugin - "-plugin"
        } else {
            pluginFullName = "${plugin}-plugin"
        }
        
        boolean usingSnapshots = false
        // Tell the user if individual plugins are set to SNAPSHOT versions.
        if (version.endsWith("-SNAPSHOT")) {
            println "Detected a changing module (e.g., under development) due to -SNAPSHOT in version: $plugin $version"
            usingSnapshots = true
        }
        // Set all plugins as SNAPSHOT versions if the global property is set.
        String pluginsSnapshotsUser = System.getProperty("holygradle.pluginsSnapshotsUser")
        if (pluginsSnapshotsUser != null) {
            version = "${pluginsSnapshotsUser}-SNAPSHOT"
            usingSnapshots = true
        }
        if (usingSnapshots) {
            // If any projects being built, or any of their dependencies, use some version of the holygradle plugins,
            // force dependency resolution to pick the SNAPSHOT version.  Note that we can't just use the
            // ReoslutionStrategy#failOnVersionConflict method because (a) some transitive dependencies of the plugins
            // themselves have version conflicts; and (b) that might also be intentionally true for other JARs added
            // to the buildcript classpath by a specific project.  (Perhaps we could warn if we find a conflict not
            // on an expected list?)
            //noinspection GroovyAssignabilityCheck
            project.gradle.allprojects { Project p ->
                p.buildscript.configurations.all { Configuration conf ->
                    // Gradle magically converts Closures to Action<>, so ignore the IntelliJ warning.
                    //noinspection GroovyAssignabilityCheck
                    resolutionStrategy.eachDependency { DependencyResolveDetails details ->
                        ModuleVersionSelector requestedVer = details.requested
                        if (requestedVer.group == group && requestedVer.name == pluginFullName) {
                            details.useVersion version
                        }
                    }
                }
            }
        }

        // Actually add the plugins to the buildscript, and record the version.
        buildscript.dependencies { DependencyHandler depHandler ->
            depHandler.add("classpath", "${group}:${pluginFullName}:${version}") { ExternalModuleDependency dep ->
                dep.changing = usingSnapshots
            }
        }
        usages[plugin] = version
    }

    // This is an API method to be called from build scripts, so suppress IntelliJ warning.
    @SuppressWarnings("GroovyUnusedDeclaration")
    public void apply() {
        Project localProject = project // allow closures to access class-private

        // Schedule 'user.gradle' files to be applied first thing after the projects are evaluated.
        project.gradle.projectsEvaluated {
            String userScript = 'user.gradle'
            File userScriptFile = new File(localProject.projectDir, userScript)
            if (userScriptFile.exists()) {
                localProject.apply from: userScriptFile.name
            } else if (localProject.buildFile != null) {
                String userBuildScript = localProject.buildFile.name.replace(".gradle", ".${userScript}")
                userScriptFile = new File(localProject.projectDir, userBuildScript)
                if (userScriptFile.exists()) {
                    localProject.apply from: userScriptFile.name
                }
            }
        }

        usages.each { name, version ->
            localProject.apply plugin: name
        }
    }  
}

final String holyGradleInitScriptVersion = "[[INIT_SCRIPT_VERSION]]"
final String holyGradleInitScriptSourceVersion = "[[INIT_SCRIPT_SOURCE_VERSION]]"

gradle.projectsLoaded { Gradle gradle ->
    Logger logger = gradle.rootProject.logger

    // We need to guard this, because the init script is run twice each time, once with "buildSrc"
    // as the root (even if there's no "buildSrc" directory) and once for the actual root project.
    if (gradle.rootProject.name != "buildSrc") {
        //If we're integration testing, dump out some extra info for debugging.
        if (PLUGINS_REPO_OVERRIDE != null) {
            gradle.rootProject.buildscript.repositories.each { ArtifactRepository repo ->
                String location = (repo.hasProperty("url") ? repo.url : "unknown location")
                logger.debug "Buildscript using repo ${repo.name} (${location})"
            }
        }
        return
    }

    logger.lifecycle("Gradle user home: ${gradle.gradleUserHomeDir}")
    logger.lifecycle("Holy Gradle init script version: ${holyGradleInitScriptVersion}")
    logger.lifecycle("Holy Gradle init script source version: ${holyGradleInitScriptSourceVersion}")
    if (holyGradleInitScriptVersion.endsWith("-SNAPSHOT")) {
        logger.warn(
            "Using SNAPSHOT version. " +
            "Gradle wrapper will NOT automatically download the latest. " +
            "You must manually delete entries in \"" + 
            (new File(gradle.getGradleUserHomeDir(), "wrapper")).toString() + "\"."
        )
    }
}

final String PLUGINS_REPO_NAME = "plugins-release"
final String REMOTE_REPO_NAME = "remote-repos"

// Gradle automagically converts the closure to an Action<Project> here, so suppress IntelliJ warning.
//noinspection GroovyAssignabilityCheck
gradle.allprojects { Project project ->
    project.ext["holyGradleInitScriptVersion"] = holyGradleInitScriptVersion
    project.ext["holyGradleInitScriptSourceVersion"] = holyGradleInitScriptSourceVersion

    // Check to see if we should add an extra local repo from which to download the Holy Gradle plugins, for integration
    // testing
    if (PLUGINS_REPO_OVERRIDE != null) {
        println "Using pluginsRepoOverride=${PLUGINS_REPO_OVERRIDE}"

        project.buildscript.repositories.ivy { IvyArtifactRepository it ->
            it.url = PLUGINS_REPO_OVERRIDE
        }
    }

    // Check if we should override use of repositories based on presence of 'local_artifacts' folder.
    // This is to support building projects without access to an Artifactory or similar repository.
    boolean usingLocalArtifacts = false
    File localArtifactsFile = new File(project.rootProject.projectDir, "local_artifacts")
    if (project == project.rootProject) {
        if (localArtifactsFile.exists()) {
            usingLocalArtifacts = true
            
            println "="*75
            println "Detected '${localArtifactsFile.name}' directory. Overriding usage of non-local repositories..."
            println "="*75
        }
    } else {
        usingLocalArtifacts = project.rootProject.property("usingLocalArtifacts")
    }
    project.ext["usingLocalArtifacts"] = usingLocalArtifacts

    if (usingLocalArtifacts) {
        // Make the "local_artifacts" folder be the first (ivy-format) repository the project will see,
        // so it will end up fetching all holygradle-packaged dependencies from there.
        project.repositories.ivy { IvyArtifactRepository it ->
            it.url = new File(localArtifactsFile, "ivy").path
        }
    }

    // Configure holyGradlePluginsRepository (ivy format) and holyGradleRemoteRepository (maven format)
    String repoBase;
    String pluginsRepo;
    String remoteRepo;
    if (usingLocalArtifacts) {
        // There is no sensible "base repo URL" in this case, and normal use of it will be overridden by the
        // "if (usingLocalArtifacts)" block above anyway, so just make it a dummy value.
        repoBase = "__using_local_artifacts";
        pluginsRepo = new File(localArtifactsFile, "ivy").toURI().toString()
        remoteRepo = new File(localArtifactsFile, "maven").toURI().toString()
    } else {
        // Get the base URL for fetching the plugins and their dependencies.  This allows the same source code to be
        // used from multiple sites which may not share a single server.  We use an environment variable instead of a
        // property because we also need to access this value from within "gw.bat", to set the distributionUrl for
        // bootstrapping the custom Gradle wrapper which contains this very init-script (and there's no easy way to
        // get at Java properties from a batch file).

        final String HOLY_GRADLE_REPOSITORY_BASE_URL_ENV_VAR_NAME = "HOLY_GRADLE_REPOSITORY_BASE_URL"
        repoBase = System.getenv(HOLY_GRADLE_REPOSITORY_BASE_URL_ENV_VAR_NAME)
        if (repoBase == null) {
            throw new RuntimeException(
                "You must set the base URL for the repository which contains the Holy Gradle plugins " +
                "and their dependencies.  To do this, set the environment variable " +
                HOLY_GRADLE_REPOSITORY_BASE_URL_ENV_VAR_NAME +
                " to the base URL for your Artifactory or other repository.  For example, " +
                "'https://artifactory-server.my-corp.com/artifactory/'"
            )
        }
        if (!repoBase.endsWith("/")) {
            repoBase += "/"
        }
        pluginsRepo = repoBase + PLUGINS_REPO_NAME
        remoteRepo = repoBase + REMOTE_REPO_NAME
    }
    project.ext["holyGradleRepositoryBase"] = repoBase
    project.ext["holyGradlePluginsRepository"] = pluginsRepo
    project.ext["holyGradleRemoteRepository"] = remoteRepo

    project.extensions.create('gplugins', HolyGradlePlugins, project.buildscript, project)
}

// Build scripts need to do the following:
/*
buildscript {
    gplugins.use "intrepid:3.0.6.+"
    gplugins.use "devenv:2.0.0.+"
}
gplugins.apply()
*/

// Unfortunately the plugin needs to be applied outside of the buildscript block. However, once
// this issue (http://issues.gradle.org/browse/GRADLE-2407) is fixed, we can tidy this up.