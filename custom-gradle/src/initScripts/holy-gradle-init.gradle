import org.gradle.api.artifacts.repositories.ArtifactRepository
import org.gradle.api.artifacts.repositories.IvyArtifactRepository
import org.gradle.api.artifacts.repositories.MavenArtifactRepository
import org.gradle.api.initialization.dsl.ScriptHandler

/**
 * This Java system property can optionally be supplied with a (file) URL value which will be added as the first repo
 * used by the build script to find plugins, so that integration tests can force locally-published versions of the
 * plugins to be tested.
 * 
 * This property key must match the one in holygradle.test.AbstractHolyGradleIntegrationTest, in
 * custom-gradle-core-plugin.
 */
final String PLUGINS_REPO_OVERRIDE_SYSTEM_PROPERTY_KEY = "holygradle.pluginsRepoOverride"
final String PLUGINS_REPO_OVERRIDE = System.getProperty(PLUGINS_REPO_OVERRIDE_SYSTEM_PROPERTY_KEY)

class HolyGradlePlugins {
    // NOTE 2013-06-07 HughG: Referenced by holygradle.custom_gradle.VersionInfo.
    public Map<String,String> usages = [:]

    private ScriptHandler buildscript
    private Project project
    
    HolyGradlePlugins(ScriptHandler buildscript, Project project) {
        this.buildscript = buildscript
        this.project = project
        // Point the buildscript to the Holy Gradle plugins.
        if (project.property("holyGradlePluginsRepository") != null) {
            buildscript.repositories { RepositoryHandler repoHandler ->
                repoHandler.ivy { IvyArtifactRepository repo ->
                    repo.url = project.property("holyGradlePluginsRepository")
                }
            }
        }
        // Point the buildscript to a source of dependencies for the Holy Gradle plugins.
        if (project.property("holyGradleRemoteRepository") != null) {
            buildscript.repositories { RepositoryHandler repoHandler ->
                repoHandler.maven { MavenArtifactRepository repo ->
                    repo.url = project.property("holyGradleRemoteRepository")
                }
            }
        }

        // By default, set the resolution strategy for buildscript dependencies so that those
        // specified with dynamic version numbers (e.g. "1.0.+") are cached for 1 hour.
        buildscript.configurations.all { Configuration conf ->
            conf.resolutionStrategy { ResolutionStrategy res ->
                res.cacheChangingModulesFor 1, 'seconds'
                res.cacheDynamicVersionsFor 1, 'hours'
            }
        }
    }
    
    public void use(String plugin_version) {
        String group = "holygradle"
        String plugin
        String version
        final String error = "Invalid format for 'gplugins.use'. The parameter should be in the form '<module>:<version>'."
        if (plugin_version.contains(":")) {
            String[] split = plugin_version.split(":")
            if (split.size() == 2) {
                plugin = split[0]
                version = split[1]
            } else if (split.size() == 3) {
                group = split[0]
                plugin = split[1]
                version = split[2]
            } else {
                throw new RuntimeException(error)
            }
        } else {
            throw new RuntimeException(error)
        }
        useInternal(group, plugin, version)
    }
    
    public void use(String plugin, String version) {
        useInternal "holygradle", plugin, version
    }
    
    private void useInternal(String group, String plugin, String version) {
        // This allows plugins to be specified as "foo" or "foo-plugin".
        String pluginFullName = null
        if (plugin.endsWith("-plugin")) {
            pluginFullName = plugin
            plugin = plugin - "-plugin"
        } else {
            pluginFullName = "${plugin}-plugin"
        }
        
        boolean usingSnapshots = false
        // Tell the user if individual plugins are set to SNAPSHOT versions.
        if (version.endsWith("-SNAPSHOT")) {
            println "Detected a changing module (e.g., under development) due to -SNAPSHOT in version: $plugin $version"
            usingSnapshots = true
        }
        // Set all plugins as SNAPSHOT versions if the global property is set.
        String pluginsSnapshotsUser = System.getProperty("holygradle.pluginsSnapshotsUser")
        if (pluginsSnapshotsUser != null) {
            version = "${pluginsSnapshotsUser}-SNAPSHOT"
            usingSnapshots = true
        }

        // Actually add the plugins to the buildscript, and record the version.
        buildscript.dependencies { DependencyHandler depHandler ->
            depHandler.add("classpath", "${group}:${pluginFullName}:${version}") { ExternalModuleDependency dep ->
                dep.changing = usingSnapshots
            }
        }
        usages[plugin] = version
    }
    
    public void apply() {
        Project localProject = project // allow closures to access class-private

        // Schedule 'user.gradle' files to be applied first thing after the projects are evaluated.
        project.gradle.projectsEvaluated {
            String userScript = 'user.gradle'
            File userScriptFile = new File(localProject.projectDir, userScript)
            if (userScriptFile.exists()) {
                localProject.apply from: userScriptFile.name
            } else if (localProject.buildFile != null) {
                String userBuildScript = localProject.buildFile.name.replace(".gradle", ".${userScript}")
                userScriptFile = new File(localProject.projectDir, userBuildScript)
                if (userScriptFile.exists()) {
                    localProject.apply from: userScriptFile.name
                }
            }
        }

        usages.each { name, version ->
            localProject.apply plugin: name
        }
    }  
}

final String holyGradleInitScriptVersion = "[[INIT_SCRIPT_VERSION]]"
final String holyGradleInitScriptSourceVersion = "[[INIT_SCRIPT_SOURCE_VERSION]]"

gradle.projectsLoaded { Gradle gradle ->
    Logger logger = gradle.rootProject.logger

    // We need to guard this, because the init script is run twice each time, once with "buildSrc"
    // as the root (even if there's no "buildSrc" directory) and once for the actual root project.
    if (gradle.rootProject.name != "buildSrc") {
        //If we're integration testing, dump out some extra info for debugging.
        if (PLUGINS_REPO_OVERRIDE != null) {
            gradle.rootProject.buildscript.repositories.each { ArtifactRepository repo ->
                String location = (repo.hasProperty("url") ? repo.url : "unknown location")
                logger.debug "Buildscript using repo ${repo.name} (${location})"
            }
        }
        return
    }

    logger.lifecycle("Gradle user home: ${gradle.gradleUserHomeDir}")
    logger.lifecycle("Holy Gradle init script version: ${holyGradleInitScriptVersion}")
    logger.lifecycle("Holy Gradle init script source version: ${holyGradleInitScriptSourceVersion}")
    if (holyGradleInitScriptVersion.endsWith("-SNAPSHOT")) {
        logger.warn(
            "Using SNAPSHOT version. " +
            "Gradle wrapper will NOT automatically download the latest. " +
            "You must manually delete entries in \"" + 
            (new File(gradle.getGradleUserHomeDir(), "wrapper")).toString() + "\"."
        )
    }
}

final String DEFAULT_PLUGINS_REPO = "[[ARTIFACTORY_SERVER]]plugins-release/"
final String DEFAULT_REMOTE_REPO = "[[ARTIFACTORY_SERVER]]remote-repos/"

// Gradle automagically converts the closure to an Action<Project> here, so suppress IntelliJ warning.
//noinspection GroovyAssignabilityCheck
gradle.allprojects { Project project ->
    project.ext["holyGradleInitScriptVersion"] = holyGradleInitScriptVersion
    project.ext["holyGradleInitScriptSourceVersion"] = holyGradleInitScriptSourceVersion

    // Check to see if we should add an extra local repo from which to download the Holy Gradle plugins, for integration
    // testing
    if (PLUGINS_REPO_OVERRIDE != null) {
        println "Using pluginsRepoOverride=${PLUGINS_REPO_OVERRIDE}"

        project.buildscript.repositories.ivy { IvyArtifactRepository it ->
            it.url = PLUGINS_REPO_OVERRIDE
        }
    }

    // Check if we should override use of repositories based on presence of 'local_artifacts' folder.
    // This is to support building projects without access to an Artifactory or similar repository.
    boolean usingLocalArtifacts = false
    File localArtifactsFile = new File(project.rootProject.projectDir, "local_artifacts")
    if (project == project.rootProject) {
        if (localArtifactsFile.exists()) {
            usingLocalArtifacts = true
            
            println "="*75
            println "Detected '${localArtifactsFile.name}' directory. Overriding usage of non-local repositories..."
            println "="*75
        }
    } else {
        usingLocalArtifacts = project.rootProject.property("usingLocalArtifacts")
    }
    project.ext["usingLocalArtifacts"] = usingLocalArtifacts
    
    if (usingLocalArtifacts) {
        project.repositories.ivy { IvyArtifactRepository it ->
            it.url = new File(localArtifactsFile, "ivy").path
        }
    }
    
    // Configure holyGradlePluginsRepository
    String pluginsRepo = DEFAULT_PLUGINS_REPO
    if (usingLocalArtifacts) {
        pluginsRepo = new File(localArtifactsFile, "ivy").path
    }
    project.ext["holyGradlePluginsRepository"] = pluginsRepo
   
    // Configure holyGradleRemoteRepository
    String remoteRepo = DEFAULT_REMOTE_REPO
    if (usingLocalArtifacts) {
        remoteRepo = new File(localArtifactsFile, "maven").path
    }
    project.ext["holyGradleRemoteRepository"] = remoteRepo
    
    project.extensions.create('gplugins', HolyGradlePlugins, project.buildscript, project)
}

// Build scripts need to do the following:
/*
buildscript {
    gplugins.use "intrepid:3.0.6.+"
    gplugins.use "devenv:2.0.0.+"
}
gplugins.apply()
*/

// Unfortunately the plugin needs to be applied outside of the buildscript block. However, once
// this issue (http://issues.gradle.org/browse/GRADLE-2407) is fixed, we can tidy this up.