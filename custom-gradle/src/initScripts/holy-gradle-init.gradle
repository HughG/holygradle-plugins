import org.gradle.api.artifacts.repositories.IvyArtifactRepository
import org.gradle.api.artifacts.repositories.MavenArtifactRepository
import org.gradle.api.initialization.dsl.ScriptHandler

class HolyGradlePlugins {
    // NOTE 2013-06-07 HughG: Referenced by holygradle.custom_gradle.VersionInfo.
    public Map<String,String> usages = [:]

    private ScriptHandler buildscript
    private Project project
    
    HolyGradlePlugins(ScriptHandler buildscript, Project project) {
        this.buildscript = buildscript
        this.project = project
        // Point the buildscript to the Holy Gradle plugins.
        if (project.ext.holyGradlePluginsRepository != null) {
            buildscript.repositories { RepositoryHandler repoHandler ->
                repoHandler.ivy { IvyArtifactRepository repo ->
                    repo.url = project.ext.holyGradlePluginsRepository
                }
            }
        }
        // Point the buildscript to a source of dependencies for the Holy Gradle plugins.
        if (project.ext.holyGradleRemoteRepository != null) {
            buildscript.repositories { RepositoryHandler repoHandler ->
                repoHandler.maven { MavenArtifactRepository repo ->
                    repo.url = project.ext.holyGradleRemoteRepository
                }
            }
        }

        // By default, set the resolution strategy for buildscript dependencies so that those
        // specified with dynamic version numbers (e.g. "1.0.+") are cached for 1 hour.
        buildscript.configurations.all { Configuration conf ->
            conf.resolutionStrategy { ResolutionStrategy res ->
                res.cacheChangingModulesFor 1, 'seconds'
                res.cacheDynamicVersionsFor 1, 'hours'
            }
        }
    }
    
    public void use(String plugin_version) {
        String group = "holygradle"
        String plugin
        String version
        final String error = "Invalid format for 'gplugins.use'. The parameter should be in the form '<module>:<version>'."
        if (plugin_version.contains(":")) {
            String[] split = plugin_version.split(":")
            if (split.size() == 2) {
                plugin = split[0]
                version = split[1]
            } else if (split.size() == 3) {
                group = split[0]
                plugin = split[1]
                version = split[2]
            } else {
                throw new RuntimeException(error)
            }
        } else {
            throw new RuntimeException(error)
        }
        useInternal(group, plugin, version)
    }
    
    public void use(String plugin, String version) {
        useInternal "holygradle", plugin, version
    }
    
    private void useInternal(String group, String plugin, String version) {
        // This allows plugins to be specified as "foo" or "foo-plugin".
        String pluginFullName = null
        if (plugin.endsWith("-plugin")) {
            pluginFullName = plugin
            plugin = plugin - "-plugin"
        } else {
            pluginFullName = "${plugin}-plugin"
        }
        
        boolean usingSnapshots = false
        // Tell the user if individual plugins are set to SNAPSHOT versions.
        if (version.endsWith("-SNAPSHOT")) {
            println "Detected a changing module (e.g., under development) due to -SNAPSHOT in version: $plugin $version"
            usingSnapshots = true
        }
        // Set all plugins as SNAPSHOT versions if the global property is set.
        if (project.hasProperty("holyGradlePluginsSnapshots") && project.holyGradlePluginsSnapshots != null) {
            version = "${project.holyGradlePluginsSnapshots}-SNAPSHOT"
            usingSnapshots = true
        }

        // Actually add the plugins to the buildscript, and record the version.
        buildscript.dependencies { DependencyHandler depHandler ->
            depHandler.add("classpath", "${group}:${pluginFullName}:${version}") { ExternalModuleDependency dep ->
                dep.changing = usingSnapshots
            }
        }
        usages[plugin] = version
    }
    
    public void apply() {
        Project localProject = project // allow closures to access class-private

        // Schedule 'user.gradle' files to be applied first thing after the projects are evaluated.
        project.gradle.projectsEvaluated {
            String userScript = 'user.gradle'
            File userScriptFile = new File(localProject.projectDir, userScript)
            if (userScriptFile.exists()) {
                localProject.apply from: userScriptFile.name
            } else if (localProject.buildFile != null) {
                String userBuildScript = localProject.buildFile.name.replace(".gradle", ".${userScript}")
                userScriptFile = new File(localProject.projectDir, userBuildScript)
                if (userScriptFile.exists()) {
                    localProject.apply from: userScriptFile.name
                }
            }
        }
        
        usages.each { name, version ->
            localProject.apply plugin: name
        }
    }  
}

String holyGradleInitScriptVersion = "[[INIT_SCRIPT_VERSION]]"
String holyGradleInitScriptSourceVersion = "[[INIT_SCRIPT_SOURCE_VERSION]]"

projectsLoaded { Gradle gradle ->
    // We need to guard this, because the init script is run twice each time, once with "buildSrc"
    // as the root (even if there's no "buildSrc" directory) and once for the actual root project.
    if (gradle.rootProject.name != "buildSrc") {
        return
    }
    getLogger().lifecycle("Holy Gradle init script version: ${holyGradleInitScriptVersion}")
    getLogger().lifecycle("Holy Gradle init script source version: ${holyGradleInitScriptSourceVersion}")
    if (holyGradleInitScriptVersion.endsWith("-SNAPSHOT")) {
        getLogger().warn(
            "Using SNAPSHOT version. " +
            "Gradle wrapper will NOT automatically download the latest. " +
            "You must manually delete entries in \"" + 
            (new File(gradle.getGradleUserHomeDir(), "wrapper")).toString() + "\"."
        )
    }
}

allprojects { Project project ->
    project.ext.holyGradleInitScriptVersion = holyGradleInitScriptVersion
    project.ext.holyGradleInitScriptSourceVersion = holyGradleInitScriptSourceVersion
    
    String defaultPluginsRepo = "http://[[ARTIFACTORY_SERVER]]/artifactory/plugins-release/"
    String defaultRemoteRepo = "http://[[ARTIFACTORY_SERVER]]/artifactory/remote-repos/"

    // Check if we should override use of repositories based on presence of 'local_artifacts' folder.
    // This is to support building projects without access to an Artifactory or similar repository.
    boolean usingLocalArtifacts = false
    File localArtifactsFile = new File(project.rootProject.projectDir, "local_artifacts")
    if (project == project.rootProject) {
        if (localArtifactsFile.exists()) {
            usingLocalArtifacts = true
            
            println "="*75
            println "Detected '${localArtifactsFile.name}' directory. Overriding usage of non-local repositories..."
            println "="*75
        }
    } else {
        usingLocalArtifacts = project.rootProject.ext.usingLocalArtifacts
    }
    project.ext.usingLocalArtifacts = usingLocalArtifacts
    
    if (usingLocalArtifacts) {
        project.repositories.ivy { IvyArtifactRepository it ->
            it.url = new File(localArtifactsFile, "ivy").path
        }
    }
    
    // Configure holyGradlePluginsRepository
    String pluginsRepo = defaultPluginsRepo
    if (usingLocalArtifacts) {
        pluginsRepo = new File(localArtifactsFile, "ivy").path
    }
    project.ext.holyGradlePluginsRepository = pluginsRepo
   
    // Configure holyGradleRemoteRepository
    String remoteRepo = defaultRemoteRepo
    if (usingLocalArtifacts) {
        remoteRepo = new File(localArtifactsFile, "maven").path
    }
    project.ext.holyGradleRemoteRepository = remoteRepo
    
    project.extensions.create('gplugins', HolyGradlePlugins, buildscript, project)
}

// Build scripts need to do the following:
/*
buildscript {
    gplugins.use "intrepid:3.0.6.+"
    gplugins.use "devenv:2.0.0.+"
}
gplugins.apply()
*/

// Unfortunately the plugin needs to be applied outside of the buildscript block. However, once
// this issue (http://issues.gradle.org/browse/GRADLE-2407) is fixed, we can tidy this up.